<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roll for Mischief - Cat Battle Royale</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #1a1a1a; 
            color: #fff; 
            font-family: monospace; 
            overflow: hidden;
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            background: #222;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        .dialog-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: #000;
            border: 3px solid #666;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.4;
            display: none;
            pointer-events: all;
        }
        .dialog-box.active { display: block; }
        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            padding: 10px;
            font-size: 12px;
            min-width: 200px;
        }
        .leaderboard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            padding: 10px;
            font-size: 12px;
            max-width: 250px;
        }
        @media (max-width: 1200px) {
            .stats-panel {
                top: 80px;
                right: 20px;
            }
            .leaderboard {
                top: 80px;
                left: 20px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="leaderboard">
            <h3>üèÜ Roll for Mischief</h3>
            <div id="leaderboard-list">Connecting...</div>
        </div>
        
        <div class="stats-panel">
            <div id="player-stats">
                <h3>Your Cat</h3>
                <div>Loading...</div>
            </div>
        </div>
        
        <div id="dialog-box" class="dialog-box">
            <div id="dialog-text">Welcome to the alley...</div>
        </div>
        
        <div class="event-log" style="position: absolute; bottom: 20px; right: 20px; width: 400px; height: 150px; background: rgba(0,0,0,0.9); border: 2px solid #444; padding: 10px; font-size: 11px; overflow-y: auto;">
            <div style="color: #888; margin-bottom: 5px;">Event Log</div>
            <div id="event-list"></div>
        </div>
    </div>

    <script>
        // Generated sprite data
const SPRITES = {
  cat: {
    data: '00000000000000000000000000000000000000000010000000000000002000000000000000340000000000000530000000000000067340000000000046700000000000000677360000000002377000000000000006777789777777A3777000000000000006777737777777377770000000000000067777777777777777700000000000000B77777777777777777000000000CC0000777777777777777777D000000E77000F7777GDH777770IJ777K00000L77700067777M007777N0PJ777D00000Q77N0006777CR007777N0SJ777K00000Q7N00006777777777777777777K00000Q7N000001377777770K7777770000000H77000000TU777777VE7777NW0000000H77000000X1337777777777E00000000H7700000AAAAA3777777773200000000H77700007777777777777777700000000H77000V777777777777777770000000007700W7777777777777777770000000007700677777777777777777700000000067056776377777777777777000000000030QY777T07777777777771000000000060H7777K07777KN77DN77A000000000060L7777K0777N0E7N0E77A000000000060Z7777D0777N0E7N0177A000000000000H7777D0777708610N77A000000000000K7773230E77L04A0N773T000000000005E7731A0H77700A0N7777D0000000000007773A0Z77700A097777D00000000000000000000000000000000000',
    colors: {
  "1": "#d07010",
  "2": "#c05000",
  "3": "#a03010",
  "4": "#d04010",
  "5": "#704010",
  "6": "#f05000",
  "7": "#f07010",
  "8": "#d04000",
  "9": "#e06010",
  "A": "#e04000",
  "B": "#f04000",
  "C": "#f08010",
  "D": "#905020",
  "E": "#d06010",
  "F": "#c04010",
  "G": "#f0a030",
  "H": "#b05020",
  "I": "#e09030",
  "J": "#f09020",
  "K": "#a05020",
  "L": "#b05010",
  "M": "#f0b040",
  "N": "#e07010",
  "P": "#e0a040",
  "Q": "#a05010",
  "R": "#f0b030",
  "S": "#e0a030",
  "T": "#c05010",
  "U": "#f06010",
  "V": "#c06010",
  "W": "#804020",
  "X": "#b03000",
  "Y": "#f07000",
  "Z": "#b06020"
},
    size: 32
  }
};
// Ultra-compressed Pathfinder 2e for 13KB - only essential features
const P = {
  // Cat classes - minimal data
  C: {
    F: { n: 'Fighter', h: 10, a: 1, s: [] }, // name, hitDie, attack bonus, spells
    R: { n: 'Rogue', h: 8, a: 1, s: ['hide', 'sneak'] }, // stealth abilities
    W: { n: 'Wizard', h: 6, a: 0, s: ['firebolt'] }, // spell list
    C: { n: 'Cleric', h: 8, a: 1, s: ['heal1', 'heal2', 'heal3', 'harm'] } // healing + harm
  },
  
  // Generate cat (ultra-minimal)
  g(n = 'Cat') {
    const keys = Object.keys(this.C);
    const c = this.C[keys[Math.floor(Math.random() * keys.length)]];
    const s = () => 10 + (Math.random() * 8 | 0); // 10-17 base stats
    const st = { S: s(), D: s(), C: s(), I: s(), W: s(), H: s() }; // STR,DEX,CON,INT,WIS,CHA
    
    // Give classes their primary stat boost and secondary stats
    if (c.n === 'Fighter') { st.S += 3; st.D += 2; } // STR 13-20, DEX 12-19 for AC
    else if (c.n === 'Rogue') st.D += 3; // DEX 13-20  
    else if (c.n === 'Wizard') { st.I += 3; st.D += 1; } // INT 13-20, DEX 11-18
    else if (c.n === 'Cleric') { st.W += 3; st.D += 1; } // WIS 13-20, DEX 11-18
    
    const hp = c.h + Math.floor((st.C - 10) / 2);
    
    // Calculate AC with class armor bonuses
    let ac = 10 + Math.floor((st.D - 10) / 2); // Base AC + DEX
    if (c.n === 'Fighter') ac += 3; // Chain mail armor
    else if (c.n === 'Cleric') ac += 2; // Scale mail armor
    
    return {
      n, c, s: st, h: hp, m: hp, // name, class, stats, hp, maxhp
      a: ac, // AC with armor
      p: { x: 0, y: 0, z: 0 }, // position
      v: true, t: 0 // alive, time
    };
  },
  
  // Roll d20 + modifier
  r(m = 0) { return Math.floor(Math.random() * 20) + 1 + m; },
  
  // Initiative
  i(cat) { return cat.i = this.r(Math.floor((cat.s.D - 10) / 2)); },
  
  // Attack (with optional MAP)
  k(a, t, map = 0) {
    const d20 = Math.floor(Math.random() * 20) + 1;
    const atkBonus = a.c.a + Math.floor((a.s.S - 10) / 2) + map;
    const total = d20 + atkBonus;
    const hit = total >= t.a;
    
    if (hit) {
      const d6 = Math.floor(Math.random() * 6) + 1;
      const strMod = Math.floor((a.s.S - 10) / 2);
      const dmg = Math.max(1, d6 + strMod);
      t.h = Math.max(0, t.h - dmg);
      if (t.h <= 0) t.v = false;
      return { h: true, d: dmg, d20, atkBonus, total, targetAC: t.a, d6, strMod };
    }
    return { h: false, d: 0, d20, atkBonus, total, targetAC: t.a };
  },
  
  // Diplomacy
  d(cat) { return this.r(Math.floor((cat.s.H - 10) / 2)) >= 12; },
  
  // Spell attacks and abilities
  spell(caster, target, spellName, range = 30) {
    const dist = target ? Math.sqrt(Math.pow(target.pos.x - caster.pos.x, 2) + Math.pow(target.pos.z - caster.pos.z, 2)) : 0;
    
    switch(spellName) {
      case 'firebolt': // Wizard ranged attack
        if (dist > range) return { h: false, msg: 'Out of range' };
        const d20 = Math.floor(Math.random() * 20) + 1;
        const intMod = Math.floor((caster.s.I - 10) / 2);
        const atkBonus = caster.c.a + intMod;
        const total = d20 + atkBonus;
        const hit = total >= target.a;
        if (hit) {
          const d10 = Math.floor(Math.random() * 10) + 1;
          const dmg = d10;
          target.h = Math.max(0, target.h - dmg);
          if (target.h <= 0) target.v = false;
          return { h: true, d: dmg, d20, atkBonus, total, targetAC: target.a, die: 'd10' };
        }
        return { h: false, d: 0, d20, atkBonus, total, targetAC: target.a };
        
      case 'harm': // Cleric ranged attack  
        if (dist > range) return { h: false, msg: 'Out of range' };
        const d20h = Math.floor(Math.random() * 20) + 1;
        const wisMod = Math.floor((caster.s.W - 10) / 2);
        const atkBonusH = caster.c.a + wisMod;
        const totalH = d20h + atkBonusH;
        const hitH = totalH >= target.a;
        if (hitH) {
          const d8 = Math.floor(Math.random() * 8) + 1;
          const dmgH = d8 + wisMod;
          target.h = Math.max(0, target.h - dmgH);
          if (target.h <= 0) target.v = false;
          return { h: true, d: dmgH, d20: d20h, atkBonus: atkBonusH, total: totalH, targetAC: target.a, die: 'd8+Wis' };
        }
        return { h: false, d: 0, d20: d20h, atkBonus: atkBonusH, total: totalH, targetAC: target.a };
        
      case 'heal1': // 1-action heal
        const heal1 = Math.floor(Math.random() * 8) + 1 + Math.floor((caster.s.W - 10) / 2);
        caster.h = Math.min(caster.m, caster.h + heal1);
        return { heal: heal1, msg: '1d8+Wis healing' };
        
      case 'heal2': // 2-action heal  
        const heal2 = (Math.floor(Math.random() * 8) + 1) * 2 + Math.floor((caster.s.W - 10) / 2);
        caster.h = Math.min(caster.m, caster.h + heal2);
        return { heal: heal2, msg: '2d8+Wis healing' };
        
      case 'heal3': // 3-action heal
        const heal3 = (Math.floor(Math.random() * 8) + 1) * 3 + Math.floor((caster.s.W - 10) / 2);
        caster.h = Math.min(caster.m, caster.h + heal3);
        return { heal: heal3, msg: '3d8+Wis healing' };
        
      case 'hide': // Rogue stealth
        caster.hidden = true;
        return { msg: 'Hidden until next attack' };
        
      case 'sneak': // Rogue sneak attack bonus
        return { sneakDmg: Math.floor(Math.random() * 6) + 1, msg: '+1d6 sneak attack' };
    }
    
    return { msg: 'Unknown spell' };
  }
};
// Minimal 3D engine for tactical cat battle royale
const E = {
  // Initialize 3D engine
  init(canvas) {
    this.c = canvas;
    this.ctx = canvas.getContext('2d');
    this.w = canvas.width = innerWidth;
    this.h = canvas.height = innerHeight;
    
    // Camera with full control
    this.cam = {
      x: 0, y: 50, z: 100,  // Position
      rx: -0.5, ry: 0, rz: 0,  // Rotation (looking down at city)
      fov: 60,  // Field of view
      zoom: 1
    };
    
    // Projection constants
    this.near = 1;
    this.far = 1000;
    
    // Scene objects
    this.objects = [];
    
    // Store cat screen positions by ID (for arrow rendering)
    this.catScreenPositions = {};
    
    // Grid size (5ft squares for Pathfinder)
    this.gridSize = 5;
  },
  
  // Add object to scene
  add(type, x, y, z, w, h, d, color) {
    const obj = { type, x, y, z, w, h, d, color };
    
    // Pre-generate window colors for buildings to prevent vibration
    if (type === 'building') {
      const windowColors = ['#FFA500', '#FFD700', '#FF8C00', '#FFAA00', '#FFCC00'];
      const floors = Math.floor(h / 10);
      obj.windowColors = [];
      
      // Generate colors for each potential window position
      for (let f = 0; f < floors; f++) {
        obj.windowColors[f] = [];
        for (let side = 0; side < 4; side++) { // front, back, left, right
          for (let pos = 0; pos < 2; pos++) { // left/right or front/back positions
            const randomIndex = Math.floor(Math.random() * windowColors.length);
            obj.windowColors[f][side * 2 + pos] = windowColors[randomIndex];
          }
        }
      }
    }
    
    this.objects.push(obj);
  },
  
  // Project 3D point to 2D screen
  project(x, y, z) {
    // Transform to camera space
    let dx = x - this.cam.x;
    let dy = y - this.cam.y;
    let dz = z - this.cam.z;
    
    // Rotate around Y (horizontal rotation)
    const cosY = Math.cos(this.cam.ry);
    const sinY = Math.sin(this.cam.ry);
    let tx = dx * cosY - dz * sinY;
    let tz = dx * sinY + dz * cosY;
    dx = tx;
    dz = tz;
    
    // Rotate around X (vertical tilt)
    const cosX = Math.cos(this.cam.rx);
    const sinX = Math.sin(this.cam.rx);
    let ty = dy * cosX - dz * sinX;
    tz = dy * sinX + dz * cosX;
    dy = ty;
    dz = tz;
    
    // Don't render behind camera
    if (dz < this.near) return null;
    
    // Perspective projection
    const scale = (this.h * 0.5) / Math.tan((this.cam.fov * 0.5) * Math.PI / 180);
    const px = (dx * scale / dz) * this.cam.zoom + this.w / 2;
    const py = (-dy * scale / dz) * this.cam.zoom + this.h / 2;
    
    return { x: px, y: py, z: dz };
  },
  
  // Draw a 3D box
  drawBox(x, y, z, w, h, d, color, opacity = 1) {
    // Define 8 vertices of the box
    const vertices = [
      { x: x, y: y, z: z },
      { x: x + w, y: y, z: z },
      { x: x + w, y: y, z: z + d },
      { x: x, y: y, z: z + d },
      { x: x, y: y + h, z: z },
      { x: x + w, y: y + h, z: z },
      { x: x + w, y: y + h, z: z + d },
      { x: x, y: y + h, z: z + d }
    ];
    
    // Project all vertices
    const projected = vertices.map(v => this.project(v.x, v.y, v.z));
    if (projected.some(p => !p)) return;
    
    // Define faces with normals for culling
    const faces = [
      { indices: [4, 5, 6, 7], color: color, normal: [0, 1, 0] },  // Top
      { indices: [0, 1, 2, 3], color: this.darken(color, 0.9), normal: [0, -1, 0] },  // Bottom
      { indices: [0, 4, 7, 3], color: this.darken(color, 0.95), normal: [-1, 0, 0] },  // Left  
      { indices: [1, 5, 6, 2], color: this.darken(color, 0.95), normal: [1, 0, 0] },  // Right
      { indices: [0, 1, 5, 4], color: this.darken(color, 0.98), normal: [0, 0, -1] },  // Front
      { indices: [3, 2, 6, 7], color: this.darken(color, 0.95), normal: [0, 0, 1] }   // Back
    ];
    
    // Face culling - only draw faces pointing toward camera
    const visibleFaces = faces.filter(face => {
      const faceCenter = [
        x + w/2 + face.normal[0] * w/2,
        y + h/2 + face.normal[1] * h/2,
        z + d/2 + face.normal[2] * d/2
      ];
      const toCam = [
        this.cam.x - faceCenter[0],
        this.cam.y - faceCenter[1], 
        this.cam.z - faceCenter[2]
      ];
      // Dot product with face normal - positive means facing camera
      return face.normal[0] * toCam[0] + face.normal[1] * toCam[1] + face.normal[2] * toCam[2] > 0;
    });
    
    // Calculate depths for visible faces
    const facesWithDepth = visibleFaces.map(face => {
      const avgZ = face.indices.reduce((sum, i) => sum + projected[i].z, 0) / face.indices.length;
      return { ...face, depth: avgZ };
    });
    
    // Sort faces by depth (painter's algorithm)
    facesWithDepth.sort((a, b) => b.depth - a.depth);
    
    // Draw faces
    this.ctx.globalAlpha = opacity;
    facesWithDepth.forEach(face => {
      this.ctx.fillStyle = face.color;
      this.ctx.beginPath();
      this.ctx.moveTo(projected[face.indices[0]].x, projected[face.indices[0]].y);
      for (let i = 1; i < face.indices.length; i++) {
        this.ctx.lineTo(projected[face.indices[i]].x, projected[face.indices[i]].y);
      }
      this.ctx.closePath();
      this.ctx.fill();
      
      // Outline for definition
      this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      this.ctx.lineWidth = 1;
      this.ctx.stroke();
    });
    this.ctx.globalAlpha = 1;
  },
  
  // Draw grid for tactical movement - draw as grid squares instead of lines
  drawGrid() {
    this.ctx.strokeStyle = 'rgba(100,100,150,0.3)';
    this.ctx.lineWidth = 1;
    
    const gridRange = 500; // Expand to cover entire play area
    for (let x = -gridRange; x <= gridRange; x += this.gridSize) {
      for (let z = -gridRange; z <= gridRange; z += this.gridSize) {
        // Draw each grid square
        const corners = [
          this.project(x, 0, z),
          this.project(x + this.gridSize, 0, z),
          this.project(x + this.gridSize, 0, z + this.gridSize),
          this.project(x, 0, z + this.gridSize)
        ];
        
        // Only draw if all corners are visible
        if (corners.every(c => c)) {
          this.ctx.beginPath();
          this.ctx.moveTo(corners[0].x, corners[0].y);
          this.ctx.lineTo(corners[1].x, corners[1].y);
          this.ctx.lineTo(corners[2].x, corners[2].y);
          this.ctx.lineTo(corners[3].x, corners[3].y);
          this.ctx.closePath();
          this.ctx.stroke();
        }
      }
    }
  },
  
  // Darken color (handles both hex and named colors)
  darken(color, factor) {
    // Handle undefined/null colors
    if (!color) return '#666666';
    
    // Handle hex colors
    if (typeof color === 'string' && color.startsWith('#')) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      const dr = Math.floor(r * factor);
      const dg = Math.floor(g * factor);
      const db = Math.floor(b * factor);
      
      return `rgb(${dr},${dg},${db})`;
    }
    
    // For non-hex colors, return as-is
    return color;
  },
  
  // Clear and setup frame
  clear() {
    // Night sky gradient
    const grad = this.ctx.createLinearGradient(0, 0, 0, this.h);
    grad.addColorStop(0, '#0a0a1a');
    grad.addColorStop(0.5, '#1a1a2e');
    grad.addColorStop(1, '#2a2a3e');
    this.ctx.fillStyle = grad;
    this.ctx.fillRect(0, 0, this.w, this.h);
    
    // Fog effect
    const fog = this.ctx.createRadialGradient(this.w/2, this.h/2, 0, this.w/2, this.h/2, this.w*0.7);
    fog.addColorStop(0, 'rgba(255,165,0,0.02)');
    fog.addColorStop(1, 'rgba(100,100,200,0.05)');
    this.ctx.fillStyle = fog;
    this.ctx.fillRect(0, 0, this.w, this.h);
  },
  
  // Render scene
  render() {
    this.clear();
    this.drawGrid();
    
    // Separate objects by type for better depth sorting
    const buildings = this.objects.filter(obj => obj.type === 'building');
    const cats = this.objects.filter(obj => obj.type === 'cat' || obj.type === 'boss');
    
    // Sort buildings by distance (back to front)
    const sortedBuildings = buildings.map(obj => {
      const dx = obj.x + obj.w/2 - this.cam.x;
      const dy = obj.y + obj.h/2 - this.cam.y;
      const dz = obj.z + obj.d/2 - this.cam.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      return { ...obj, dist };
    }).sort((a, b) => b.dist - a.dist);
    
    // Sort cats by distance
    const sortedCats = cats.map(obj => {
      const dx = obj.x + obj.w/2 - this.cam.x;
      const dy = obj.y + obj.h/2 - this.cam.y;
      const dz = obj.z + obj.d/2 - this.cam.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      return { ...obj, dist };
    }).sort((a, b) => b.dist - a.dist);
    
    // Draw buildings first (furthest to nearest)
    sortedBuildings.forEach(obj => {
      this.drawBox(obj.x, obj.y, obj.z, obj.w, obj.h, obj.d, obj.color);
      this.drawBuildingWindows(obj);
    });
    
    // Draw cats on top (with proper depth relative to buildings)
    sortedCats.forEach(catObj => {
      // Check if cat is behind any building
      let blocked = false;
      for (const buildingObj of sortedBuildings) {
        if (this.isObjectBehind(catObj, buildingObj)) {
          blocked = true;
          break;
        }
      }
      
      if (!blocked) {
        this.drawCat(catObj);
      }
    });
    
    // Calculate screen positions for ALL cats after rendering (for arrow positioning)
    sortedCats.forEach(catObj => {
      this.calculateCatScreenPosition(catObj);
    });
  },
  
  // Calculate screen position for cat sprite (for arrow positioning)
  calculateCatScreenPosition(obj) {
    if (!obj.catId) return; // Skip if no catId
    
    const { x, y, z, w, h, d } = obj;
    
    // Project sprite center to screen (same logic as drawCat)
    const screenPos = this.project(x + w/2, y + h, z + d/2);
    if (!screenPos) return;
    
    // Calculate sprite size (same logic as drawCat)
    const dx = (x + w/2) - this.cam.x;
    const dy = (y + h/2) - this.cam.y;  
    const dz = (z + d/2) - this.cam.z;
    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    const worldSize = 5; // 5 feet tall in game world
    const distanceFromCamera = screenPos.z;
    const spriteSize = Math.max(8, worldSize * 800 / distanceFromCamera);
    
    // Store in global map by catId
    const spriteTop = screenPos.y - spriteSize;
    this.catScreenPositions[obj.catId] = { x: screenPos.x, y: spriteTop };
  },
  
  // Check if object A is behind object B from camera perspective
  isObjectBehind(objA, objB) {
    const aCenter = {
      x: objA.x + objA.w/2,
      y: objA.y + objA.h/2,
      z: objA.z + objA.d/2
    };
    const bCenter = {
      x: objB.x + objB.w/2,
      y: objB.y + objB.h/2,
      z: objB.z + objB.d/2
    };
    
    // Simple AABB intersection test in 2D (x,z plane)
    const aLeft = objA.x;
    const aRight = objA.x + objA.w;
    const aFront = objA.z;
    const aBack = objA.z + objA.d;
    
    const bLeft = objB.x;
    const bRight = objB.x + objB.w;
    const bFront = objB.z;
    const bBack = objB.z + objB.d;
    
    // Check for 2D overlap in x,z plane
    const overlapX = aRight > bLeft && aLeft < bRight;
    const overlapZ = aBack > bFront && aFront < bBack;
    
    if (overlapX && overlapZ) {
      // Calculate distance from camera
      const aDist = Math.sqrt(
        (aCenter.x - this.cam.x) ** 2 + 
        (aCenter.y - this.cam.y) ** 2 + 
        (aCenter.z - this.cam.z) ** 2
      );
      const bDist = Math.sqrt(
        (bCenter.x - this.cam.x) ** 2 + 
        (bCenter.y - this.cam.y) ** 2 + 
        (bCenter.z - this.cam.z) ** 2
      );
      
      // A is behind B if it's further from camera and overlaps
      return aDist > bDist;
    }
    
    return false;
  },
  
  // Draw a 3D triangle
  drawTriangle(v1, v2, v3, color) {
    // Project vertices
    const p1 = this.project(v1.x, v1.y, v1.z);
    const p2 = this.project(v2.x, v2.y, v2.z);
    const p3 = this.project(v3.x, v3.y, v3.z);
    
    // Skip if any vertex is behind camera
    if (!p1 || !p2 || !p3) return;
    
    // Calculate normal for backface culling
    const edge1 = { x: v2.x - v1.x, y: v2.y - v1.y, z: v2.z - v1.z };
    const edge2 = { x: v3.x - v1.x, y: v3.y - v1.y, z: v3.z - v1.z };
    const normal = {
      x: edge1.y * edge2.z - edge1.z * edge2.y,
      y: edge1.z * edge2.x - edge1.x * edge2.z,
      z: edge1.x * edge2.y - edge1.y * edge2.x
    };
    
    // Face center for culling test
    const center = {
      x: (v1.x + v2.x + v3.x) / 3,
      y: (v1.y + v2.y + v3.y) / 3,
      z: (v1.z + v2.z + v3.z) / 3
    };
    
    const toCam = {
      x: this.cam.x - center.x,
      y: this.cam.y - center.y,
      z: this.cam.z - center.z
    };
    
    // Skip back-facing triangles
    const dot = normal.x * toCam.x + normal.y * toCam.y + normal.z * toCam.z;
    if (dot < 0) return;
    
    // Draw triangle
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(p1.x, p1.y);
    this.ctx.lineTo(p2.x, p2.y);
    this.ctx.lineTo(p3.x, p3.y);
    this.ctx.closePath();
    this.ctx.fill();
    
    // Subtle outline
    this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    this.ctx.lineWidth = 0.5;
    this.ctx.stroke();
  },
  
  // Sprite system - uses generated SPRITES data
  sprites: typeof SPRITES !== 'undefined' ? {
    cat: SPRITES.cat.data,
    colors: SPRITES.cat.colors,
    size: SPRITES.cat.size
  } : {
    // Fallback sprites if SPRITES not loaded
    cat: '00000000000000000000000000000000',
    colors: {'0': 'rgba(0,0,0,0)'},
    size: 16
  },
  
  // Draw sprite using classic matrix access [row*size+col] 
  drawSprite(spriteStr, colors, x, y, size, spriteSize = 32, tintColor = null, options = {}) {
    const pixelSize = size / spriteSize;
    const { isDefeated = false, clipToHead = false, isBoss = false } = options;
    
    // For defeated cats, only render the head portion (skull effect)
    const startRow = clipToHead ? 2 : 0; // Start a bit lower to get ears
    const endRow = clipToHead ? 16 : spriteSize; // Include more of head
    const startCol = clipToHead ? 8 : 0; // Trim left side  
    const endCol = clipToHead ? spriteSize : spriteSize; // Keep full right side
    
    for (let row = startRow; row < endRow; row++) {
      for (let col = startCol; col < endCol; col++) {
        const char = spriteStr[row * spriteSize + col];
        let color = colors[char];
        
        if (color) { // Skip transparent (0)
          // Apply defeated effect (bleached/grayscale)
          if (isDefeated) {
            color = this.bleachColor(color);
          } else if (isBoss) {
            // Boss cat is pure black/dark
            color = this.darkenColor(color);
          } else if (tintColor) {
            // Apply tint color if provided (only for living cats)
            color = this.blendColors(color, tintColor);
          }
          
          this.ctx.fillStyle = color;
          this.ctx.fillRect(x + col * pixelSize, y + row * pixelSize, pixelSize, pixelSize);
        }
      }
    }
    
    // Draw special eyes
    if (isDefeated && clipToHead) {
      this.drawDefeatedEyes(x, y, size, spriteSize);
    } else if (isBoss) {
      this.drawBossEyes(x, y, size, spriteSize);
    }
  },
  
  // Blend original color with tint color
  blendColors(baseColor, tintColor) {
    // Moderate tint blend - mix 60% original + 40% tint
    const base = this.hexToRgb(baseColor);
    const tint = this.hexToRgb(tintColor);
    const tintStrength = 0.4;
    
    const r = Math.floor(base.r * (1 - tintStrength) + tint.r * tintStrength);
    const g = Math.floor(base.g * (1 - tintStrength) + tint.g * tintStrength);
    const b = Math.floor(base.b * (1 - tintStrength) + tint.b * tintStrength);
    
    return `rgb(${r},${g},${b})`;
  },
  
  // Convert hex to RGB
  hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
  },
  
  // Convert color to bleached/grayscale for defeated cats
  bleachColor(color) {
    const rgb = this.hexToRgb(color);
    // Convert to grayscale using luminance formula, then brighten
    const gray = Math.floor((rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11) * 1.5);
    const bleached = Math.min(255, gray);
    return `rgb(${bleached},${bleached},${bleached})`;
  },
  
  // Darken color for boss cat
  darkenColor(color) {
    const rgb = this.hexToRgb(color);
    // Make it very dark/black
    const dark = Math.floor((rgb.r * 0.3 + rgb.g * 0.3 + rgb.b * 0.3) * 0.2);
    return `rgb(${dark},${dark},${dark})`;
  },
  
  // Draw X eyes for defeated cats
  drawDefeatedEyes(x, y, size, spriteSize) {
    const pixelSize = size / spriteSize;
    this.ctx.fillStyle = '#000000';
    
    // Eye positions (adjusted to match actual cat eye locations)
    const leftEyeX = x + 14 * pixelSize;
    const rightEyeX = x + 22 * pixelSize;
    const eyeY = y + 10 * pixelSize;
    const eyeWidth = pixelSize * 4;
    const eyeHeight = pixelSize * 3;
    
    // Draw black rectangle for left eye
    this.ctx.fillRect(leftEyeX, eyeY, eyeWidth, eyeHeight);
    
    // Draw black rectangle for right eye  
    this.ctx.fillRect(rightEyeX, eyeY, eyeWidth, eyeHeight);
  },
  
  // Draw yellow eyes for boss cat
  drawBossEyes(x, y, size, spriteSize) {
    const pixelSize = size / spriteSize;
    this.ctx.fillStyle = '#ffff00';
    
    // Eye positions (same as defeated eyes)
    const leftEyeX = x + 14 * pixelSize;
    const rightEyeX = x + 22 * pixelSize;
    const eyeY = y + 10 * pixelSize;
    const eyeWidth = pixelSize * 4;
    const eyeHeight = pixelSize * 3;
    
    // Draw yellow rectangle for left eye
    this.ctx.fillRect(leftEyeX, eyeY, eyeWidth, eyeHeight);
    
    // Draw yellow rectangle for right eye  
    this.ctx.fillRect(rightEyeX, eyeY, eyeWidth, eyeHeight);
  },
  
  // Draw cat using DOOM-style billboard sprite system
  drawCat(obj) {
    const { x, y, z, w, h, d, color, type } = obj;
    
    // Calculate distance from camera to original position for culling
    const dx = x - this.cam.x;
    const dy = (y + h/2) - this.cam.y;  
    const dz = z - this.cam.z;
    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    // Skip if too far away
    if (distance > this.far) return;
    
    // Calculate grid square bounds and force cat to ground plane center
    const gridX = Math.floor(x / this.gridSize) * this.gridSize;
    const gridZ = Math.floor(z / this.gridSize) * this.gridSize;
    const gridSize = type === 'boss' ? this.gridSize * 2 : this.gridSize;
    
    // Force cat to exact center of grid square on ground plane
    const centerX = gridX + gridSize/2;
    const centerZ = gridZ + gridSize/2;
    const screenPos = this.project(centerX, 0, centerZ); // Force to ground (y=0)
    if (!screenPos) return;
    
    // Calculate corners for highlight
    const corners = [
      this.project(gridX, 0, gridZ),
      this.project(gridX + gridSize, 0, gridZ),
      this.project(gridX + gridSize, 0, gridZ + gridSize),
      this.project(gridX, 0, gridZ + gridSize)
    ];
    
    // Fixed size sprites - consistent size regardless of distance
    const spriteSize = type === 'boss' ? 80 : 40; // Boss bigger than regular cats
    
    // Check if cat is defeated by looking up in game state
    let isDefeated = false;
    if (obj.catId && window.G && window.G.turnOrder) {
      const catData = window.G.turnOrder.find(cat => cat.id === obj.catId);
      isDefeated = catData && !catData.v; // v = alive
      if (isDefeated) {
        console.log(`Cat ${obj.catId} is defeated: hp=${catData.h}, alive=${catData.v}`);
      }
    }
    
    // Draw highlight square for active player's grid position only
    if (window.G && window.G.combat && window.G.turnOrder) {
      const activeCat = window.G.turnOrder[window.G.currentTurn];
      const isActiveCat = obj.catId === activeCat.id;
      
      if (isActiveCat) {
        this.ctx.strokeStyle = isDefeated ? 'rgba(100,100,100,0.8)' : 'rgba(255,255,0,0.8)';
        this.ctx.lineWidth = 3;
        
        // Fill the square with a subtle glow
        this.ctx.fillStyle = isDefeated ? 'rgba(100,100,100,0.1)' : 'rgba(255,255,0,0.1)';
        if (corners.every(c => c)) {
          this.ctx.beginPath();
          this.ctx.moveTo(corners[0].x, corners[0].y);
          this.ctx.lineTo(corners[1].x, corners[1].y);
          this.ctx.lineTo(corners[2].x, corners[2].y);
          this.ctx.lineTo(corners[3].x, corners[3].y);
          this.ctx.closePath();
          this.ctx.fill();
          this.ctx.stroke();
        }
      }
    }
    
    // Draw sprite as billboard (always faces camera)
    let spriteTop = screenPos.y - spriteSize;
    
    // Boss cat needs to render lower since it's bigger
    if (type === 'boss') {
      spriteTop += 10; // Lower the boss sprite (split the difference)
    }
    
    // Defeated cats need offset too since they're clipped
    if (isDefeated) {
      spriteTop += spriteSize * 0.4; // Pull skull sprites down
    }
    
    this.drawSprite(
      this.sprites.cat, 
      this.sprites.colors,
      screenPos.x - spriteSize/2, 
      spriteTop, 
      spriteSize,
      this.sprites.size, // Use dynamic sprite size
      type === 'boss' ? null : color, // Boss is black (no tint), others get tint
      { isDefeated, clipToHead: isDefeated, isBoss: type === 'boss' } // Pass defeat options
    );
    
    // Store sprite screen position for arrow rendering
    obj.screenTop = { x: screenPos.x, y: spriteTop };
  },
  
  // Draw windows only on visible building faces with varied colors/sizes
  drawBuildingWindows(building) {
    const { x, y, z, w, h, d, windowColors } = building;
    
    // Check which faces are visible using same logic as drawBox
    const faces = [
      { normal: [-1, 0, 0], side: 'left', index: 0 },   // Left face
      { normal: [1, 0, 0], side: 'right', index: 1 },   // Right face
      { normal: [0, 0, -1], side: 'front', index: 2 },  // Front face
      { normal: [0, 0, 1], side: 'back', index: 3 }     // Back face
    ];
    
    // Use exact same face culling logic as drawBox
    const visibleFaces = faces.filter(face => {
      const faceCenter = [
        x + w/2 + face.normal[0] * w/2,
        y + h/2 + face.normal[1] * h/2,
        z + d/2 + face.normal[2] * d/2
      ];
      const toCam = [
        this.cam.x - faceCenter[0],
        this.cam.y - faceCenter[1], 
        this.cam.z - faceCenter[2]
      ];
      // Dot product with face normal - positive means facing camera
      return face.normal[0] * toCam[0] + face.normal[1] * toCam[1] + face.normal[2] * toCam[2] > 0;
    });

    visibleFaces.forEach(face => {
        // More windows per building - every 6 units instead of 10
        const windowSpacing = 6;
        const windowRows = Math.floor(h / windowSpacing);
        
        for (let f = 1; f <= windowRows; f++) {
          const wy = f * windowSpacing - 3;
          
          // Minimum square height that can grow taller
          const windowW = 2.5; // Fixed width
          const minH = windowW; // Minimum = square (same as width)
          const maxH = windowW * 2; // Can grow up to 2x width
          const seed = Math.sin(f * 1.7 + x * 0.3 + z * 0.7) * 0.5 + 0.5;
          
          // Check if window would exceed building height with padding
          const padding = 3; // Leave 3 units from top
          const maxAllowedH = Math.max(minH, h - wy - padding);
          const clampedMaxH = Math.min(maxH, maxAllowedH);
          const windowH = minH + seed * (clampedMaxH - minH);
          
          // Use pre-generated colors to prevent vibration
          const colorIndex = Math.floor((f - 1) * 4 + face.index * 2);
          const windowColor = windowColors && windowColors[f - 1] && windowColors[f - 1][colorIndex] 
            ? windowColors[f - 1][colorIndex] 
            : '#FFA500'; // fallback
          
          if (face.side === 'front') {
            this.drawBox(x + 2, y + wy, z - 0.1, windowW, windowH, 0.2, windowColor);
            if (w > 10) {
              const colorIndex2 = colorIndex + 1;
              const windowColor2 = windowColors && windowColors[f - 1] && windowColors[f - 1][colorIndex2] 
                ? windowColors[f - 1][colorIndex2] 
                : '#FFD700'; // fallback
              this.drawBox(x + w - 2 - windowW, y + wy, z - 0.1, windowW, windowH, 0.2, windowColor2);
            }
          } else if (face.side === 'back') {
            this.drawBox(x + 2, y + wy, z + d - 0.1, windowW, windowH, 0.2, windowColor);
            if (w > 10) {
              const colorIndex2 = colorIndex + 1;
              const windowColor2 = windowColors && windowColors[f - 1] && windowColors[f - 1][colorIndex2] 
                ? windowColors[f - 1][colorIndex2] 
                : '#FFD700'; // fallback
              this.drawBox(x + w - 2 - windowW, y + wy, z + d - 0.1, windowW, windowH, 0.2, windowColor2);
            }
          } else if (face.side === 'left') {
            this.drawBox(x - 0.1, y + wy, z + 2, 0.2, windowH, windowW, windowColor);
            if (d > 10) {
              const colorIndex2 = colorIndex + 1;
              const windowColor2 = windowColors && windowColors[f - 1] && windowColors[f - 1][colorIndex2] 
                ? windowColors[f - 1][colorIndex2] 
                : '#FFD700'; // fallback
              this.drawBox(x - 0.1, y + wy, z + d - 2 - windowW, 0.2, windowH, windowW, windowColor2);
            }
          } else if (face.side === 'right') {
            this.drawBox(x + w - 0.1, y + wy, z + 2, 0.2, windowH, windowW, windowColor);
            if (d > 10) {
              const colorIndex2 = colorIndex + 1;
              const windowColor2 = windowColors && windowColors[f - 1] && windowColors[f - 1][colorIndex2] 
                ? windowColors[f - 1][colorIndex2] 
                : '#FFD700'; // fallback
              this.drawBox(x + w - 0.1, y + wy, z + d - 2 - windowW, 0.2, windowH, windowW, windowColor2);
            }
          }
        }
    });
  },
  
  // Camera controls
  moveCamera(dx, dy, dz) {
    this.cam.x += dx;
    this.cam.y += dy;
    this.cam.z += dz;
  },
  
  rotateCamera(drx, dry) {
    this.cam.rx = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cam.rx + drx));
    this.cam.ry += dry;
  },
  
  zoomCamera(factor) {
    this.cam.zoom = Math.max(0.5, Math.min(3, this.cam.zoom * factor));
  },
  
  // Set camera to isometric view
  setIsometric() {
    this.cam.rx = -Math.PI / 4;
    this.cam.ry = Math.PI / 4;
    this.cam.y = 50;
    this.cam.zoom = 1;
  }
};
// Tactical cat battle royale with full 3D movement
let G = {
  s: 'splash', // 'splash', 'menu', 'playing', 'combat'
  p: null,
  cs: [],
  t: 0,
  k: new Set(),
  mouseDrag: false,
  rightMouseDrag: false,
  lastMouse: { x: 0, y: 0 },
  
  // WebSocket
  w: null,
  id: 'cat_' + (Math.random() * 1e6 | 0),
  
  // Combat state
  combat: null,
  turnOrder: [],
  currentTurn: 0,
  currentActions: 3,
  actionType: null, // 'move' or 'attack'
  attackCount: 0,
  moveDistance: 0, // Track movement used this turn
  eventLog: [],
  targetDialog: null, // Target selection state
  healDialog: false, // Healing spell selection
  showStatBlock: false, // T key toggle for stat display
  
  // Menu state
  menuSelection: 0, // 0 = Start Game, 1 = Join Game
  roomCode: '', // 4-letter room code
  gameMode: null, // 'host' or 'join'
  connectedPlayers: 0, // Number of connected players
  ws: null, // WebSocket connection
  
  // Initialize
  init() {
    console.log('INIT CALLED');
    
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.initAfterDOM());
    } else {
      this.initAfterDOM();
    }
  },
  
  initAfterDOM() {
    console.log('INIT AFTER DOM CALLED');
    const canvas = document.querySelector('canvas');
    console.log('CANVAS FOUND:', canvas);
    
    E.init(canvas);
    
    // Initialize city/grid for menu background
    this.generateCity();
    
    // Cat colors for differentiation (work better with orange base)
    this.catColors = ['#ffaa00', '#ff2222', '#88ff88', '#ffffff', '#ff44ff', '#ffff44', '#44ffff'];
    
    // Camera controls - set up once
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) {  // Left click
        this.mouseDrag = true;
      } else if (e.button === 2) {  // Right click
        this.rightMouseDrag = true;
        e.preventDefault();
      }
      this.lastMouse = { x: e.clientX, y: e.clientY };
    });
    
    canvas.addEventListener('mouseup', () => {
      this.mouseDrag = false;
      this.rightMouseDrag = false;
    });
    
    canvas.addEventListener('contextmenu', e => {
      e.preventDefault(); // Disable right-click menu
    });
    
    canvas.addEventListener('mousemove', e => {
      if (this.mouseDrag || this.rightMouseDrag) {
        const dx = e.clientX - this.lastMouse.x;
        const dy = e.clientY - this.lastMouse.y;
        
        if (this.mouseDrag) {
          // Left drag: rotate camera
          E.rotateCamera(-dy * 0.01, dx * 0.01);
        } else if (this.rightMouseDrag) {
          // Right drag: move camera relative to rotation
          const moveSpeed = 0.5;
          const camYaw = E.cam.ry;
          const cos = Math.cos(camYaw);
          const sin = Math.sin(camYaw);
          
          // Horizontal drag = strafe left/right relative to camera
          const strafeX = dx * cos * moveSpeed;
          const strafeZ = dx * sin * moveSpeed;
          
          // Vertical drag = move forward/back relative to camera
          const forwardX = -dy * sin * moveSpeed;
          const forwardZ = dy * cos * moveSpeed;
          
          E.moveCamera(strafeX + forwardX, 0, strafeZ + forwardZ);
        }
        
        this.lastMouse = { x: e.clientX, y: e.clientY };
      }
    });
    
    // Set up keyboard controls now that DOM is ready
    this.setupKeyboardControls();
    
    // Hide UI elements initially (in splash state)
    this.updateUI();
    
    // Start animation loop
    this.loop();
  },
  
  spawnCats() {
    // Clear any existing objects
    E.objects = [];
    this.cs = [];
    
    // Only generate player if not already created (for non-multiplayer or if missing)
    if (!this.p) {
      this.p = P.g('You');
      this.p.id = this.id; // Use the unique session ID
      const angle = Math.random() * Math.PI * 2;
      const distance = 4 + Math.floor(Math.random() * 7); // 4-10 grid units from center
      const rawX = Math.cos(angle) * distance * 5; // 5-unit grid
      const rawZ = Math.sin(angle) * distance * 5;
      this.p.pos = { 
        x: Math.round(rawX / 5) * 5, // Snap to 5-unit grid
        y: 0, 
        z: Math.round(rawZ / 5) * 5 
      };
      this.p.color = this.catColors[0]; // Player gets first color
    }
    this.lastCatPos = { x: this.p.pos.x, z: this.p.pos.z };
    
    // Add player to scene
    E.add('cat', this.p.pos.x, this.p.pos.y, this.p.pos.z, 3, 5, 3, this.p.color);
    // Set catId on the player's object
    const playerObj = E.objects[E.objects.length - 1];
    playerObj.catId = this.p.id;
    
    // Add BOSS CAT - 10ft x 10ft black cat
    const boss = P.g('??????');
    boss.id = 'boss';
    boss.n = '??????';
    // Create copy of class to avoid corrupting shared reference
    boss.c = { ...boss.c, n: '??????' };
    boss.isBoss = true;
    // Make boss challenging but balanced
    boss.h = boss.m = 60; // 60 HP (reduced from 100)
    boss.a = 16; // High but not impossible AC
    boss.c.a = 3; // Moderate attack bonus
    boss.s = { S: 16, D: 14, C: 16, I: 10, W: 12, H: 8 }; // Strong but balanced stats
    boss.color = '#000000'; // Black
    boss.pos = { x: 0, y: 0, z: 30 }; // Center-back position
    this.cs.push(boss);
    const bossObj = { type: 'boss', x: boss.pos.x, y: boss.pos.y, z: boss.pos.z, w: 10, h: 10, d: 10, color: boss.color, catId: boss.id };
    E.objects.push(bossObj);
    
    // Add any joined players to the cats array
    if (this.joinedPlayers) {
      this.joinedPlayers.forEach(joinedPlayer => {
        this.cs.push(joinedPlayer);
        E.add('cat', joinedPlayer.pos.x, joinedPlayer.pos.y, joinedPlayer.pos.z, 3, 5, 3, joinedPlayer.color);
        E.objects[E.objects.length - 1].catId = joinedPlayer.id;
      });
    }

    // Fill remaining slots with AI cats up to 6 total players (not counting boss)
    const totalPlayers = 6;
    const aiCatsNeeded = totalPlayers - this.connectedPlayers;
    const usedPositions = new Set(['0,0', '0,30']); // Player at origin, boss at 0,30
    
    // Mark joined player positions as used
    if (this.joinedPlayers) {
      this.joinedPlayers.forEach(p => {
        usedPositions.add(`${p.pos.x},${p.pos.z}`);
      });
    }
    
    for (let i = 0; i < aiCatsNeeded; i++) {
      const aiCat = P.g(`AI Cat ${i+1}`);
      aiCat.id = `ai_${i}`;
      aiCat.isAI = true; // Mark as AI for turn behavior
      aiCat.color = this.catColors[i + 1]; // Each AI gets different color
      
      // Find available grid position
      let x, z, posKey;
      do {
        x = (Math.floor(Math.random() * 12) - 6) * 5; // -30 to +30 in 5ft increments
        z = (Math.floor(Math.random() * 12) - 6) * 5;
        posKey = `${x},${z}`;
      } while (usedPositions.has(posKey));
      
      usedPositions.add(posKey);
      aiCat.pos = { x, y: 0, z };
      this.cs.push(aiCat);
      const catObj = { type: 'cat', x: aiCat.pos.x, y: aiCat.pos.y, z: aiCat.pos.z, w: 3, h: 5, d: 3, color: aiCat.color, catId: aiCat.id };
      E.objects.push(catObj);
    }
    
    // Add player to cats array
    this.cs.unshift(this.p);
    
    // Debug: Log final cat breakdown
    console.log('=== FINAL CAT BREAKDOWN ===');
    console.log('Total cats:', this.cs.length);
    console.log('Connected players:', this.connectedPlayers);
    console.log('AI cats needed:', 6 - this.connectedPlayers);
    console.log('Cats by type:');
    this.cs.forEach((c, i) => {
      const type = c.isBoss ? 'BOSS' : (c.isAI ? 'AI' : 'PLAYER');
      console.log(`  ${i}: ${type} - ${c.c.n}(${c.id})`);
    });
    console.log('===========================');
    
    // Position camera behind and above cat for proper view
    E.cam.x = this.p.pos.x;
    E.cam.y = 25;  
    E.cam.z = this.p.pos.z + 25;  // Behind cat (positive Z)
    E.cam.rx = -0.3;  // Looking down at cat
    E.cam.ry = Math.PI;  // Face towards cat
    
    // Camera controls - use E.canvas
    if (E.canvas && !this.cameraControlsSetup) {
      this.cameraControlsSetup = true; // Prevent duplicate listeners
      E.canvas.addEventListener('mousedown', e => {
        if (e.button === 0) {  // Left click
          this.mouseDrag = true;
        } else if (e.button === 2) {  // Right click
          this.rightMouseDrag = true;
          e.preventDefault();
        }
        this.lastMouse = { x: e.clientX, y: e.clientY };
      });
    
      E.canvas.addEventListener('mouseup', () => {
        this.mouseDrag = false;
        this.rightMouseDrag = false;
      });
      
      E.canvas.addEventListener('contextmenu', e => {
        e.preventDefault(); // Disable right-click menu
      });
      
      E.canvas.addEventListener('mousemove', e => {
        if (this.mouseDrag || this.rightMouseDrag) {
          const dx = e.clientX - this.lastMouse.x;
        const dy = e.clientY - this.lastMouse.y;
        
        if (this.mouseDrag) {
          // Left drag: rotate camera
          E.rotateCamera(-dy * 0.01, dx * 0.01);
        } else if (this.rightMouseDrag) {
          // Right drag: move camera relative to rotation
          const moveSpeed = 0.5;
          const camYaw = E.cam.ry;
          const cos = Math.cos(camYaw);
          const sin = Math.sin(camYaw);
          
          // Horizontal drag = strafe left/right relative to camera
          const strafeX = dx * cos * moveSpeed;
          const strafeZ = dx * sin * moveSpeed;
          
          // Vertical drag = move up/down (global Y)
          E.moveCamera(strafeX, -dy * moveSpeed, strafeZ);
        }
        
        this.lastMouse = { x: e.clientX, y: e.clientY };
      }
    });
    
      E.canvas.addEventListener('wheel', e => {
        const factor = e.deltaY > 0 ? 1.1 : 0.9;
        E.zoomCamera(factor);
        e.preventDefault();
      });
    }
    
  },
  
  setupKeyboardControls() {
    console.log('SETTING UP KEYBOARD CONTROLS');
    
    // Complete keyboard handler
    document.addEventListener('keydown', (e) => {
      console.log('KEY:', e.key, e.code, 'STATE:', this.s);
      this.k.add(e.code);
      
      if (e.code === 'Space' || e.key === ' ') {
        console.log('SPACE DETECTED IN STATE:', this.s);
        e.preventDefault();
        if (this.s === 'splash') {
          this.s = 'menu';
          console.log('CHANGED STATE TO MENU');
        } else if (this.combat) {
          if (this.gameMode === 'host') {
            this.nextTurn();
          } else {
            this.send('end_turn', {});
          }
        }
      }
      
      // Menu navigation
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        this.menuUp();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        this.menuDown();
      }
      if (e.code === 'Enter') {
        this.menuSelect();
      }
      
      // Game controls
      if (e.code === 'KeyI') E.setIsometric();
      
      // Only allow action commands if it's the player's turn
      const isMyTurn = this.combat && this.turnOrder && this.turnOrder[this.currentTurn]?.id === this.p?.id;
      if (isMyTurn) {
        if (e.code === 'KeyM') this.setAction('move');
        if (e.code === 'KeyX') this.setAction('attack');
        if (e.code === 'KeyC') this.setAction('cast');
        if (e.code === 'KeyH') this.setAction('heal');
        if (e.code === 'KeyZ') this.setAction('stealth');
      }
      if (e.code === 'KeyT') this.showStatBlock = !this.showStatBlock;
      if (e.code === 'Escape') this.endAction();
      
      // Target selection with digit keys
      if (this.targetDialog) {
        if (e.code === 'Digit1') this.selectTarget(1);
        if (e.code === 'Digit2') this.selectTarget(2);
        if (e.code === 'Digit3') this.selectTarget(3);
        if (e.code === 'Digit4') this.selectTarget(4);
        if (e.code === 'Digit5') this.selectTarget(5);
        if (e.code === 'Digit6') this.selectTarget(6);
      }
      
      // Heal selection with digit keys
      if (this.healDialog) {
        if (e.code === 'Digit1') this.executeHeal(1);
        if (e.code === 'Digit2') this.executeHeal(2);
        if (e.code === 'Digit3') this.executeHeal(3);
      }
    });
    
    document.addEventListener('keyup', (e) => {
      this.k.delete(e.code);
    });
    
    console.log('KEYBOARD SETUP COMPLETE');
  },
  
  // Connect to multiplayer
  connect() {
    try {
      this.w = new WebSocket('wss://relay.js13kgames.com/roll-for-mischief');
      this.w.onopen = () => this.send('join', { id: this.id, cat: this.p });
      this.w.onmessage = e => {
        try {
          const msg = JSON.parse(e.data);
          this.handle(msg);
        } catch (err) {}
      };
    } catch (e) {}
  },
  
  // Send message
  send(type, data) {
    if (this.w && this.w.readyState === 1) {
      this.w.send(JSON.stringify({ type, data: { ...data, id: this.id } }));
    }
  },
  
  // Handle message
  handle(msg) {
    switch (msg.type) {
      case 'join':
        if (msg.data.id !== this.id) {
          const cat = msg.data.cat;
          cat.id = msg.data.id;
          this.cs.push(cat);
          E.add('cat', cat.pos.x, cat.pos.y, cat.pos.z, 3, 5, 3, '#654321');
        }
        break;
      case 'move':
        if (msg.data.id !== this.id) {
          const cat = this.cs.find(c => c.id === msg.data.id);
          if (cat) {
            cat.pos = msg.data.pos;
            const catObj = E.objects.find(obj => obj.type === 'cat' && obj.x === cat.pos.x && obj.z === cat.pos.z);
            if (catObj) {
              catObj.x = cat.pos.x;
              catObj.z = cat.pos.z;
            }
          }
        }
        break;
    }
  },
  
  // Generate 3D city with proper streets
  generateCity(forGame = false, buildingData = null) {
    console.log('generateCity called:', { forGame, hasBuildingData: !!buildingData, state: this.s });
    
    // Only generate buildings when explicitly requested or in playing state
    if (forGame) {
      console.log('BUILDING GENERATION STARTING');
      
      if (buildingData) {
        console.log('Using provided building data:', buildingData.length);
        // Use provided building data (for clients)
        buildingData.forEach(b => {
          E.add('building', b.x, b.y, b.z, b.w, b.h, b.d, b.color);
        });
        return;
      }
      
      console.log('Generating new buildings for host');
      // Street width = 20ft (4 tiles)
      // Buildings are 30x30ft on average
      
      for (let bx = -5; bx <= 5; bx++) {
        for (let bz = -5; bz <= 5; bz++) {
          // Building block position
          const blockX = bx * 60; // 30ft building + 30ft space
          const blockZ = bz * 60;
          
          // Skip center for spawn
          if (Math.abs(bx) <= 1 && Math.abs(bz) <= 1) continue;
          
          // Building dimensions
          const w = 25 + Math.random() * 10; // 25-35ft
          const h = 15 + Math.random() * 50; // 15-65ft tall
          const d = 25 + Math.random() * 10;
          
          // Building color variants
          const colors = ['#4a4a6a', '#5a5a7a', '#6a5a7a', '#5a6a7a'];
          const color = colors[Math.floor(Math.random() * colors.length)];
          
          const x = blockX - w/2, y = 0, z = blockZ - d/2;
          console.log('Adding building:', { x, y, z, w, h, d, color });
          E.add('building', x, y, z, w, h, d, color);
          
          // Store building data for syncing
          if (this.buildings) {
            this.buildings.push({ x, y, z, w, h, d, color });
            console.log('Stored building, total:', this.buildings.length);
          }
        }
      }
      
      // Add some smaller buildings between blocks
      for (let i = 0; i < 20; i++) {
        const x = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 400;
        
        // Don't place too close to center
        if (Math.abs(x) < 50 && Math.abs(z) < 50) continue;
        
        const w = 10 + Math.random() * 15;
        const h = 8 + Math.random() * 25;
        const d = 10 + Math.random() * 15;
        
        const y = 0, color = '#3a3a5a';
        E.add('building', x, y, z, w, h, d, color);
        
        // Store building data for syncing
        if (this.buildings) {
          this.buildings.push({ x, y, z, w, h, d, color });
        }
      }
    }
  },
  
  // Game loop
  loop() {
    this.update();
    this.render();
    requestAnimationFrame(() => this.loop());
  },
  
  // Update
  update() {
    // Only update game world when actually playing and player exists
    if (this.s === 'playing' && this.p) {
      this.updateCamera();
      this.updatePlayer();
    }
  },
  
  // Update camera movement
  updateCamera() {
    const speed = 2;
    
    // Calculate movement relative to camera rotation
    const camYaw = -E.cam.ry;  // Try negative to fix coordination
    const cos = Math.cos(camYaw);
    const sin = Math.sin(camYaw);
    
    
    if (this.k.has('KeyW')) {
      // Forward relative to camera
      E.moveCamera(-sin * speed, 0, cos * speed);
    }
    if (this.k.has('KeyS')) {
      // Backward relative to camera
      E.moveCamera(sin * speed, 0, -cos * speed);
    }
    if (this.k.has('KeyA')) {
      // Left relative to camera
      E.moveCamera(-cos * speed, 0, -sin * speed);
    }
    if (this.k.has('KeyD')) {
      // Right relative to camera
      E.moveCamera(cos * speed, 0, sin * speed);
    }
    if (this.k.has('KeyQ')) E.moveCamera(0, speed, 0);
    if (this.k.has('KeyE')) E.moveCamera(0, -speed, 0);
  },
  
  // Check if position is occupied by a cat
  occupied(x, z, e = null) {
    // Check player position
    if (this.p && this.p !== e && this.p.pos.x === x && this.p.pos.z === z) return 1;
    
    // Check all cats
    return this.cs.some(c => {
      if (c === e || !c.v) return false;
      
      if (c.isBoss) {
        // Boss cat occupies 2x2 grid (10ft x 10ft)
        const bossLeft = c.pos.x - 5;
        const bossRight = c.pos.x + 5;
        const bossTop = c.pos.z - 5;
        const bossBottom = c.pos.z + 5;
        
        return x >= bossLeft && x <= bossRight && z >= bossTop && z <= bossBottom;
      } else {
        // Regular cat occupies single 5ft square
        return c.pos.x === x && c.pos.z === z;
      }
    });
  },
  
  // Update player
  updatePlayer() {
    if (!this.p || !this.p.pos) return; // Wait for player and position to be initialized
    
    const moveDelay = 300; // Turn-based feel
    const now = Date.now();
    
    if (this.combat) {
      // In combat, only current player can move and must have actions/move selected
      if (this.turnOrder[this.currentTurn]?.id !== this.p.id) return;
      if (this.actionType !== 'move' || this.currentActions <= 0) return;
      if (this.moveDistance >= 25) return; // Max 25ft movement per turn
    }
    
    if (!this.lastMove || now - this.lastMove > moveDelay) {
      let moved = false; // Define moved outside both branches
      
      if (this.gameMode === 'host') {
        // Host processes movement locally
        const gridSize = 5; // 5ft squares
        let newX = this.p.pos.x;
        let newZ = this.p.pos.z;
        
        // Calculate new position based on input
        if (this.k.has('ArrowUp')) {
          newZ -= gridSize;  // North
        }
        if (this.k.has('ArrowDown')) {
          newZ += gridSize;  // South
        }
        if (this.k.has('ArrowLeft')) {
          newX -= gridSize;  // West
        }
        if (this.k.has('ArrowRight')) {
          newX += gridSize;  // East
        }
        
        // Only move if the new position is not occupied
        if ((newX !== this.p.pos.x || newZ !== this.p.pos.z) && !this.occupied(newX, newZ, this.p)) {
          this.p.pos.x = newX;
          this.p.pos.z = newZ;
          moved = true;
        }
      } else {
        // Client sends movement request to host
        const gridSize = 5;
        let newX = this.p.pos.x;
        let newZ = this.p.pos.z;
        let requestMove = false;
        
        // Calculate desired position
        if (this.k.has('ArrowUp')) {
          newZ -= gridSize;
          requestMove = true;
        }
        if (this.k.has('ArrowDown')) {
          newZ += gridSize;
          requestMove = true;
        }
        if (this.k.has('ArrowLeft')) {
          newX -= gridSize;
          requestMove = true;
        }
        if (this.k.has('ArrowRight')) {
          newX += gridSize;
          requestMove = true;
        }
        
        if (requestMove && (newX !== this.p.pos.x || newZ !== this.p.pos.z)) {
          this.send('player_move', { targetX: newX, targetZ: newZ, playerId: this.p.id });
          this.lastMove = now; // Prevent spam
        }
        return; // Don't process locally
      }
      
      if (moved) {
        this.lastMove = now;
        
        // Track movement distance in combat
        if (this.combat && this.actionType === 'move') {
          this.moveDistance += 5;
          this.addEvent(`Moved 5ft (${this.moveDistance}/25ft used)`);
          
          // Consume action every 25ft of movement
          if (this.moveDistance >= 25) {
            this.currentActions--;
            this.moveDistance = 0; // Reset for next action
            this.addEvent(`Movement action consumed. ${this.currentActions} actions remaining.`);
            if (this.currentActions <= 0) this.actionType = null;
          }
        }
        
        // Update cat in scene
        const catIndex = E.objects.findIndex(obj => obj.type === 'cat');
        if (catIndex >= 0) {
          E.objects[catIndex].x = this.p.pos.x;
          E.objects[catIndex].z = this.p.pos.z;
        }
        
        // Send movement to other players
        this.send('move', { pos: this.p.pos });
        
        // Check for nearby enemies
        this.checkCombat();
        
        // Camera following - move camera by same amount cat moved
        const deltaX = this.p.pos.x - this.lastCatPos.x;
        const deltaZ = this.p.pos.z - this.lastCatPos.z;
        
        E.cam.x += deltaX;  // Move camera by exact same amount
        E.cam.z += deltaZ;
        
        // Store current cat position for next time
        this.lastCatPos = { x: this.p.pos.x, z: this.p.pos.z };
      }
    }
  },
  
  // Check for combat initiation
  checkCombat() {
    // Look for nearby cats within 30ft (6 squares)
    const nearby = this.cs.filter(cat => {
      const dx = cat.pos.x - this.p.pos.x;
      const dz = cat.pos.z - this.p.pos.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      return dist <= 30 && cat.v;
    });
    
    if (nearby.length > 0 && !this.combat) {
      this.startCombat([this.p, ...nearby]);
    }
  },
  
  // Start tactical combat
  startCombat(cats) {
    this.combat = {
      participants: cats,
      round: 1
    };
    
    // Roll initiative for all participants
    cats.forEach(cat => P.i(cat));
    this.turnOrder = cats.sort((a, b) => b.i - a.i);
    
    // Start with highest initiative (index 0)
    this.currentTurn = 0;
    
    console.log(`Combat started! Turn order: ${this.turnOrder.map(c => c.c.n).join(', ')}`);
    
    // Start the first turn
    const firstCat = this.turnOrder[0];
    this.addEvent(`${firstCat.c.n}'s turn begins`);
    
    // If first cat is AI, trigger its behavior
    if (firstCat !== this.p && firstCat.v) {
      setTimeout(() => this.runAITurn(firstCat), 1000);
    }
    
    // Position camera for combat
    const centerX = cats.reduce((sum, c) => sum + c.pos.x, 0) / cats.length;
    const centerZ = cats.reduce((sum, c) => sum + c.pos.z, 0) / cats.length;
    
    E.cam.x = centerX;
    E.cam.z = centerZ + 40;
    E.cam.y = 25;
    E.cam.rx = -0.3;
  },
  
  // Handle space key
  handleSpace() {
    if (this.s === 'splash') {
      this.s = 'menu';
    } else if (this.combat) {
      this.nextTurn();
    }
  },
  
  // Menu navigation
  menuUp() {
    if (this.s === 'menu') {
      this.menuSelection = Math.max(0, this.menuSelection - 1);
    } else if (this.s === 'lobby' && this.gameMode === 'host') {
      this.menuSelection = Math.max(0, this.menuSelection - 1);
    }
  },
  
  menuDown() {
    if (this.s === 'menu') {
      this.menuSelection = Math.min(1, this.menuSelection + 1);
    } else if (this.s === 'lobby' && this.gameMode === 'host') {
      this.menuSelection = Math.min(2, this.menuSelection + 1);
    }
  },
  
  menuSelect() {
    if (this.s === 'menu') {
      if (this.menuSelection === 0) {
        this.startGame();
      } else {
        this.joinGame();
      }
    } else if (this.s === 'lobby') {
      if (this.gameMode === 'host') {
        if (this.menuSelection === 0) {
          // Start with current players
          console.log('Host starting game, sending game_start message');
          this.send('game_start', { roomCode: this.roomCode });
          this.s = 'playing';
          this.initGame();
          // Send full game state after initialization
          setTimeout(() => {
            console.log('Host sending game state');
            this.syncGameState();
          }, 500);
        } else if (this.menuSelection === 1) {
          // Start solo
          this.connectedPlayers = 1;
          this.s = 'playing';
          this.initGame();
        } else {
          // Back to menu
          this.s = 'menu';
          this.menuSelection = 0;
        }
      } else {
        // Joined player - only back to menu option
        this.s = 'menu';
        this.menuSelection = 0;
      }
    }
  },
  
  startGame() {
    this.gameMode = 'host';
    this.roomCode = this.generateRoomCode();
    console.log('Starting game with room code:', this.roomCode);
    this.s = 'lobby';
    this.connectToLobby();
  },
  
  joinGame() {
    this.gameMode = 'join';
    const code = prompt('Enter 4-letter room code:');
    if (code && code.length === 4) {
      this.roomCode = code.toUpperCase();
      console.log('Joining game with room code:', this.roomCode);
      this.s = 'lobby';
      this.connectToJoinLobby();
    }
  },

  connectToJoinLobby() {
    try {
      this.connectedPlayers = 0; // Will be updated when we join
      this.ws = new WebSocket('wss://relay.js13kgames.com/roll-for-mischief');
      this.ws.onopen = () => {
        // Generate client's player character
        this.generateClientPlayer();
        this.send('join_room', { id: this.id, playerData: this.p });
        console.log('Joining lobby as player:', this.roomCode);
        // Request current room state after a brief delay
        setTimeout(() => {
          this.send('request_room_state', { id: this.id });
        }, 100);
      };
      this.ws.onmessage = e => {
        // Skip non-JSON messages (relay server sends @ and + prefixed messages)
        if (typeof e.data === 'string' && (e.data.startsWith('@') || e.data.startsWith('+'))) {
          return;
        }
        try {
          const msg = JSON.parse(e.data);
          this.handleLobbyMessage(msg);
        } catch (err) {
          console.error('WebSocket message error:', err);
        }
      };
      this.ws.onclose = () => console.log('WebSocket closed');
      this.ws.onerror = err => console.error('WebSocket error:', err);
    } catch (err) {
      console.error('WebSocket connection failed:', err);
      this.connectedPlayers = 1; // Fallback to offline mode
    }
  },
  
  connectToLobby() {
    try {
      // Generate host's player character  
      this.generateClientPlayer();
      this.connectedPlayers = 1; // Host starts with 1
      this.ws = new WebSocket('wss://relay.js13kgames.com/roll-for-mischief');
      this.ws.onopen = () => {
        this.send('create_room', { roomCode: this.roomCode, id: this.id, host: true });
        console.log('Connected to lobby as host:', this.roomCode);
      };
      this.ws.onmessage = e => {
        // Skip non-JSON messages (relay server sends @ and + prefixed messages)
        if (typeof e.data === 'string' && (e.data.startsWith('@') || e.data.startsWith('+'))) {
          return;
        }
        try {
          const msg = JSON.parse(e.data);
          this.handleLobbyMessage(msg);
        } catch (err) {
          console.error('WebSocket message error:', err);
        }
      };
      this.ws.onclose = () => console.log('WebSocket closed');
      this.ws.onerror = err => console.error('WebSocket error:', err);
    } catch (err) {
      console.error('WebSocket connection failed:', err);
      this.connectedPlayers = 1; // Fallback to offline mode
    }
  },

  send(type, data) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      // Send to relay - it will broadcast to other clients
      const message = JSON.stringify({ type, ...data, room: this.roomCode });
      this.ws.send(message);
      console.log('Sending:', message);
    }
  },

  handleLobbyMessage(msg) {
    console.log('Lobby message received:', msg);
    
    // TEMPORARILY REMOVE ROOM FILTERING TO DEBUG
    // if (msg.room !== this.roomCode && msg.roomCode !== this.roomCode) {
    //   return;
    // }
    
    if (msg.type === 'create_room' && msg.host && msg.id !== this.id) {
      // Someone else created this room - shouldn't happen
      return;
    }
    
    if (msg.type === 'join_room' && msg.id !== this.id) {
      // Another player joined our room
      if (this.gameMode === 'host') {
        this.connectedPlayers++;
        // Store the joining player's character data
        if (msg.playerData && msg.playerData.id !== this.id) {
          if (!this.joinedPlayers) this.joinedPlayers = [];
          this.joinedPlayers.push(msg.playerData);
        }
        // Host broadcasts updated count to all
        this.send('room_update', { playerCount: this.connectedPlayers });
      }
    } else if (msg.type === 'room_update') {
      // Update from host about room state
      if (msg.playerCount !== undefined) {
        this.connectedPlayers = msg.playerCount;
      }
    } else if (msg.type === 'request_room_state') {
      // Someone is requesting room state - host responds
      if (this.gameMode === 'host') {
        this.send('room_update', { playerCount: this.connectedPlayers });
      }
    } else if (msg.type === 'game_start') {
      // Host started the game - clients wait for game_state
      console.log('Client received game_start message');
      if (this.gameMode !== 'host') {
        console.log('Client transitioning to playing state');
        this.s = 'playing';
        // Don't generate anything - wait for complete game_state from host
      }
    } else if (msg.type === 'game_state') {
      // Receive full game state from host
      this.receiveGameState(msg);
    } else if (msg.type === 'turn_update') {
      // Receive turn state update
      this.receiveTurnUpdate(msg);
    } else if (msg.type === 'player_attack' && this.gameMode === 'host') {
      // Client is requesting to attack - process on host
      this.handleClientAttack(msg);
    } else if (msg.type === 'end_turn' && this.gameMode === 'host') {
      // Client is requesting to end turn - process on host
      this.nextTurn();
    } else if (msg.type === 'player_move' && this.gameMode === 'host') {
      // Client is requesting to move - process on host
      this.handleClientMove(msg);
    } else if (msg.type === 'event_broadcast') {
      // Client receives event from host - add directly to avoid prompt filtering
      this.eventLog.unshift(msg.text);
      if (this.eventLog.length > 8) this.eventLog.pop();
      
      // Update HTML event log directly
      const eventList = document.querySelector('#event-list');
      if (eventList) {
        const eventDiv = document.createElement('div');
        eventDiv.style.color = '#00ff00';
        eventDiv.style.marginBottom = '2px';
        eventDiv.textContent = msg.text;
        eventList.insertBefore(eventDiv, eventList.firstChild);
        
        while (eventList.children.length > 8) {
          eventList.removeChild(eventList.lastChild);
        }
      }
    }
  },

  // Generate client player (clients only)
  generateClientPlayer() {
    // Add player-specific entropy to randomization
    const idHash = this.id.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) & 0xffffffff, 0);
    const entropy = Math.abs(idHash) / 0xffffffff;
    
    // Add small delay based on ID to offset random timing
    Math.random(); // Consume one random for entropy offset
    for (let i = 0; i < (Math.abs(idHash) % 10); i++) {
      Math.random(); // Advance random state by different amounts per player
    }
    
    this.p = P.g('You');
    this.p.id = this.id; // Use unique session ID
    
    // Use ID-based angle to ensure different positions
    const angle = (entropy * Math.PI * 2) + Math.random() * Math.PI * 0.5;
    const distance = 4 + Math.floor(Math.random() * 7);
    const rawX = Math.cos(angle) * distance * 5;
    const rawZ = Math.sin(angle) * distance * 5;
    this.p.pos = { 
      x: Math.round(rawX / 5) * 5, 
      y: 0, 
      z: Math.round(rawZ / 5) * 5 
    };
    
    // Assign client a unique color based on ID hash
    const colorIndex = 1 + (Math.abs(idHash) % (this.catColors.length - 1));
    this.p.color = this.catColors[colorIndex];
  },

  // Handle client attack request (host only)
  handleClientAttack(msg) {
    // Find the attacking player and target
    const attackerId = msg.id || msg.playerId; // Message should include client's player ID
    const attacker = this.turnOrder.find(c => c.id === attackerId);
    const target = this.turnOrder.find(c => c.id === msg.targetId);
    
    if (!attacker || !target) {
      console.error('Invalid attack request:', { attackerId, targetId: msg.targetId });
      return;
    }
    
    // Process the attack
    const map = (attacker.attackCount || 0) * -5; // Multiple Attack Penalty
    const result = P.k(attacker, target, map);
    
    // Update attacker state
    attacker.attackCount = (attacker.attackCount || 0) + 1;
    this.currentActions--;
    
    // Add event log
    const mapText = map < 0 ? ` (MAP ${map})` : '';
    const bonusText = result.atkBonus >= 0 ? `+${result.atkBonus}` : `${result.atkBonus}`;
    const rollText = `1d20${bonusText} [${result.total}] vs AC ${result.targetAC}`;
    
    if (result.h) {
      const strText = result.strMod >= 0 ? `+${result.strMod}` : `${result.strMod}`;
      const dmgText = `1d6${strText} [${result.d}]`;
      this.addEvent(`${attacker.c.n} claw attack${mapText}: ${rollText} HIT for ${dmgText} damage`);
      if (!target.v) this.addEvent(`${target.c.n} is defeated!`);
    } else {
      this.addEvent(`${attacker.c.n} claw attack${mapText}: ${rollText} MISS`);
    }
    
    // Sync the updated game state to all clients
    this.syncGameState();
  },

  // Handle client move request (host only)
  handleClientMove(msg) {
    // Find the moving player
    const playerId = msg.playerId;
    const player = this.turnOrder.find(c => c.id === playerId);
    
    if (!player) {
      console.error('Invalid move request - player not found:', playerId);
      return;
    }
    
    // Check if move is valid
    const newX = msg.targetX;
    const newZ = msg.targetZ;
    
    if (!this.occupied(newX, newZ, player)) {
      // Move is valid - update position
      player.pos.x = newX;
      player.pos.z = newZ;
      
      // Update visual object
      const catIndex = E.objects.findIndex(obj => (obj.type === 'cat' || obj.type === 'boss') && obj.catId === player.id);
      if (catIndex >= 0) {
        E.objects[catIndex].x = newX;
        E.objects[catIndex].z = newZ;
      }
      
      // Track movement for combat
      if (this.combat && this.currentTurn < this.turnOrder.length) {
        const currentPlayer = this.turnOrder[this.currentTurn];
        if (currentPlayer.id === playerId && this.actionType === 'move') {
          this.moveDistance += 5;
          this.addEvent(`${player.c.n} moved 5ft (${this.moveDistance}/25ft used)`);
          
          // Consume action every 25ft
          if (this.moveDistance >= 25) {
            this.currentActions--;
            this.moveDistance = 0;
            this.addEvent(`Movement action consumed. ${this.currentActions} actions remaining.`);
            if (this.currentActions <= 0) this.actionType = null;
          }
        }
      }
      
      // Sync updated game state
      this.syncGameState();
    }
  },

  // Sync full game state (host only)
  syncGameState() {
    console.log('syncGameState called:', { gameMode: this.gameMode, hasCombat: !!this.combat });
    if (this.gameMode !== 'host' || !this.combat) {
      console.log('syncGameState early return:', { gameMode: this.gameMode, hasCombat: !!this.combat });
      return;
    }
    
    const gameState = {
      cats: this.cs.map(c => ({
        id: c.id, n: c.n, pos: c.pos, h: c.h, m: c.m, a: c.a, v: c.v,
        c: c.c, s: c.s, color: c.color, i: c.i, isBoss: c.isBoss, isAI: c.isAI
      })),
      buildings: this.buildings || [],
      turnOrder: this.turnOrder.map(c => c.id),
      currentTurn: this.currentTurn,
      currentActions: this.currentActions,
      combat: { round: this.combat.round },
      eventLog: this.eventLog || []
    };
    
    this.send('game_state', gameState);
  },

  // Receive game state from host
  receiveGameState(msg) {
    if (this.gameMode === 'host') return; // Ignore if we're host
    
    console.log('Receiving game state:', msg);
    
    // Clear all existing objects
    E.objects = [];
    
    // Generate buildings from host data
    if (msg.buildings && msg.buildings.length > 0) {
      this.generateCity(true, msg.buildings);
    }
    
    // Update cats
    this.cs = msg.cats.map(data => {
      const cat = { ...data };
      if (cat.isBoss) {
        // Boss cat is 10x10x10
        const bossObj = { type: 'boss', x: cat.pos.x, y: cat.pos.y, z: cat.pos.z, w: 10, h: 10, d: 10, color: cat.color, catId: cat.id };
        E.objects.push(bossObj);
      } else {
        // Regular cat
        E.add('cat', cat.pos.x, cat.pos.y, cat.pos.z, 3, 5, 3, cat.color);
        E.objects[E.objects.length - 1].catId = cat.id;
      }
      return cat;
    });

    // Find this client's player in the cats array
    this.p = this.cs.find(c => c.id === this.id);
    
    if (this.p) {
      // Position camera behind player
      E.cam.x = this.p.pos.x;
      E.cam.y = 25;  
      E.cam.z = this.p.pos.z + 25;
      E.cam.rx = -0.3;
      E.cam.ry = Math.PI;
    }
    
    // Update turn order - all cats are already in this.cs
    this.turnOrder = msg.turnOrder.map(id => 
      this.cs.find(c => c.id === id)
    ).filter(c => c);
    
    // Update combat state
    this.currentTurn = msg.currentTurn;
    this.currentActions = msg.currentActions;
    this.combat = { participants: [...this.cs, this.p], ...msg.combat };
    
    // Update event log
    if (msg.eventLog) {
      this.eventLog = msg.eventLog;
    }
    
    console.log('Client game state updated:', { 
      cats: this.cs.length, 
      turnOrder: this.turnOrder.map(c => c.c.n), 
      currentTurn: this.currentTurn 
    });
  },

  // Send turn update (host only)
  syncTurnState() {
    if (this.gameMode !== 'host') return;
    
    this.send('turn_update', {
      currentTurn: this.currentTurn,
      currentActions: this.currentActions,
      round: this.combat.round
    });
  },

  // Receive turn update
  receiveTurnUpdate(msg) {
    if (this.gameMode === 'host') return;
    
    this.currentTurn = msg.currentTurn;
    this.currentActions = msg.currentActions;
    if (this.combat) this.combat.round = msg.round;
  },
  
  renderLobby() {
    const ctx = E.ctx;
    
    const centerX = E.w / 2;
    const centerY = E.h / 2;
    
    // Title
    ctx.font = '48px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffaa00';
    ctx.fillText('Game Lobby', centerX, centerY - 150);
    
    // Room code display
    ctx.font = '32px monospace';
    ctx.fillStyle = '#00ffff';
    ctx.fillText(`Room Code: ${this.roomCode}`, centerX, centerY - 80);
    
    // Player count
    ctx.font = '24px monospace';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Players Connected: ${this.connectedPlayers}/6`, centerX, centerY - 40);
    
    // Options - different for host vs joined players
    ctx.font = '20px monospace';
    if (this.gameMode === 'host') {
      const options = ['Start Game (with current players)', 'Start Game (solo)', 'Back to Menu'];
      options.forEach((option, i) => {
        const y = centerY + 20 + (i * 30);
        ctx.fillStyle = this.menuSelection === i ? '#ffffff' : '#888888';
        ctx.fillText(option, centerX, y);
      });
    } else {
      // Joined player - just show waiting status
      ctx.fillStyle = '#cccccc';
      ctx.fillText('Waiting for host to start the game...', centerX, centerY + 20);
      ctx.font = '16px monospace';
      const option = 'Back to Menu';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(option, centerX, centerY + 60);
    }
    
    // Instructions
    ctx.font = '16px monospace';
    ctx.fillStyle = '#cccccc';
    ctx.textAlign = 'left';
    ctx.fillText('Use W/S or Arrow Keys to navigate', 20, E.h - 60);
    ctx.fillText('Press ENTER to select', 20, E.h - 40);
    ctx.fillText('Other players can join with room code', 20, E.h - 20);
  },
  
  generateRoomCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let code = '';
    for (let i = 0; i < 4; i++) {
      code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
  },
  
  initGame() {
    if (this.gameInitialized) {
      console.log('INITGAME ALREADY CALLED - SKIPPING');
      return;
    }
    this.gameInitialized = true;
    
    console.log('INITGAME CALLED - HOST GENERATING WORLD');
    // Initialize game world  
    this.buildings = []; // Store building data
    this.spawnCats();
    this.generateCity(true);
    
    // Start combat after a brief delay with all cats
    setTimeout(() => {
      const allCats = this.cs.filter(c => c && c.v);
      if (allCats.length > 0) {
        this.startCombat(allCats);
      }
    }, 500);
  },
  
  // Add event to log
  addEvent(text, isPrompt = false) {
    this.eventLog.unshift(text);
    if (this.eventLog.length > 8) this.eventLog.pop(); // Keep last 8 events
    
    // Host broadcasts non-prompt events to clients
    // Never broadcast player-specific prompts or selections
    const shouldNotBroadcast = isPrompt || 
      text.includes('Selected') && text.includes('action') ||
      text.includes('Choose') ||
      text.includes('No enemies in range') ||
      text.includes('Not enough actions') ||
      /^\d+\)/.test(text); // Any line starting with number and parenthesis
    
    const shouldBroadcast = this.gameMode === 'host' && !shouldNotBroadcast;
    
    if (shouldBroadcast) {
      this.send('event_broadcast', { text });
    }
    
    // Update HTML event log
    const eventList = document.querySelector('#event-list');
    if (eventList) {
      const eventDiv = document.createElement('div');
      eventDiv.style.color = '#00ff00';
      eventDiv.style.marginBottom = '2px';
      eventDiv.textContent = text;
      eventList.insertBefore(eventDiv, eventList.firstChild);
      
      // Remove old events
      while (eventList.children.length > 8) {
        eventList.removeChild(eventList.lastChild);
      }
    }
  },
  
  // Simple text wrapping
  wrapText(text, maxLength) {
    if (text.length <= maxLength) return [text];
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
      if ((currentLine + word).length <= maxLength) {
        currentLine += (currentLine ? ' ' : '') + word;
      } else {
        if (currentLine) lines.push(currentLine);
        currentLine = word;
      }
    });
    if (currentLine) lines.push(currentLine);
    return lines;
  },
  
  // Show target selection dialog
  showTargetDialog(targets, actionType) {
    this.targetDialog = { targets, actionType };
    this.addEvent(`Choose target (1-${targets.length}):`, true);
    targets.forEach((t, i) => {
      this.addEvent(`${i + 1}) ${t.c.n} Cat`, true);
    });
  },
  
  // Handle target selection input
  selectTarget(number) {
    if (!this.targetDialog) return;
    
    const index = number - 1;
    if (index >= 0 && index < this.targetDialog.targets.length) {
      const target = this.targetDialog.targets[index];
      if (this.targetDialog.actionType === 'attack') {
        this.executeAttack(target);
      } else if (this.targetDialog.actionType === 'cast') {
        this.executeCast(target, this.targetDialog.spell);
      }
      this.targetDialog = null;
    }
  },

  // Set current action type
  setAction(type) {
    if (!this.combat || this.currentActions <= 0) return;
    if (this.turnOrder[this.currentTurn]?.id !== this.p.id) return;
    
    this.actionType = type;
    this.addEvent(`Selected ${type} action`, true);
    
    // Auto-execute based on action type
    if (type === 'attack') {
      this.attemptAttack();
    } else if (type === 'cast') {
      this.attemptCast();
    } else if (type === 'heal') {
      this.attemptHeal();
    } else if (type === 'stealth') {
      this.attemptStealth();
    }
  },
  
  // End current action
  endAction() {
    if (!this.combat || this.turnOrder[this.currentTurn]?.id !== this.p.id) return;
    
    if (this.actionType === 'move' && this.moveDistance > 0) {
      // Consume action for partial movement
      this.currentActions--;
      this.addEvent(`Movement ended. ${this.currentActions} actions remaining.`);
      this.moveDistance = 0;
    }
    
    this.actionType = null;
  },
  
  // Attempt attack on nearby enemies
  attemptAttack() {
    const enemies = this.cs.filter(cat => {
      if (!cat.v || cat.id === this.p.id) return false; // Exclude dead cats and self
      
      if (cat.isBoss) {
        // Boss cat occupies 2x2 grid - check adjacency to any square
        const bossLeft = cat.pos.x - 5;
        const bossRight = cat.pos.x + 5;
        const bossTop = cat.pos.z - 5;
        const bossBottom = cat.pos.z + 5;
        
        // Check if player is adjacent to any edge of the boss area
        const adjacentX = (this.p.pos.x === bossLeft - 5) || (this.p.pos.x === bossRight + 5);
        const adjacentZ = (this.p.pos.z === bossTop - 5) || (this.p.pos.z === bossBottom + 5);
        const overlapX = this.p.pos.x >= bossLeft - 5 && this.p.pos.x <= bossRight + 5;
        const overlapZ = this.p.pos.z >= bossTop - 5 && this.p.pos.z <= bossBottom + 5;
        
        return (adjacentX && overlapZ) || (adjacentZ && overlapX);
      } else {
        // Regular cat - adjacent grid square check (including diagonal)
        const dx = Math.abs(cat.pos.x - this.p.pos.x);
        const dz = Math.abs(cat.pos.z - this.p.pos.z);
        return dx <= 5 && dz <= 5;
      }
    });
    
    if (enemies.length === 0) {
      this.addEvent('No enemies in range for attack', true);
      return;
    }
    
    if (enemies.length === 1) {
      // Auto-attack single target
      const target = enemies[0];
      this.executeAttack(target);
    } else {
      // Multiple targets - show numbered selection
      this.showTargetDialog(enemies, 'attack');
    }
  },
  
  // Execute attack on specific target
  executeAttack(target) {
    if (this.gameMode === 'host') {
      // Host processes attack locally
      const map = this.attackCount * -5; // Multiple Attack Penalty
      const result = P.k(this.p, target, map);
      
      this.currentActions--;
      this.attackCount++;
      
      const mapText = map < 0 ? ` (MAP ${map})` : '';
      const bonusText = result.atkBonus >= 0 ? `+${result.atkBonus}` : `${result.atkBonus}`;
      const rollText = `1d20${bonusText} [${result.total}] vs AC ${result.targetAC}`;
      
      if (result.h) {
        const strText = result.strMod >= 0 ? `+${result.strMod}` : `${result.strMod}`;
        const dmgText = `1d6${strText} [${result.d}]`;
        this.addEvent(`Claw attack${mapText}: ${rollText} HIT for ${dmgText} damage`);
        if (!target.v) this.addEvent(`${target.c.n} is defeated!`);
      } else {
        this.addEvent(`Claw attack${mapText}: ${rollText} MISS`);
      }
      
      // Sync game state after player attack
      this.syncGameState();
    } else {
      // Client sends attack command to host
      this.send('player_attack', { targetId: target.id, playerId: this.p.id });
    }
    
    // Check if combat should end
    const alive = this.turnOrder.filter(cat => cat.v);
    if (alive.length <= 1) {
      this.endCombat();
      return;
    }
    
    if (this.currentActions <= 0) this.actionType = null;
  },
  
  // Attempt cast spell
  attemptCast() {
    const spells = this.p.c.s || [];
    const offensiveSpells = spells.filter(s => s === 'firebolt' || s === 'harm');
    
    if (offensiveSpells.length === 0) {
      this.addEvent('No offensive spells available');
      return;
    }
    
    const spell = offensiveSpells[0]; // Use first available
    const enemies = this.cs.filter(cat => {
      if (!cat.v || cat.id === this.p.id) return false; // Exclude dead cats and self
      const dx = cat.pos.x - this.p.pos.x;
      const dz = cat.pos.z - this.p.pos.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      return dist <= 30; // 30ft range
    });
    
    if (enemies.length === 0) {
      this.addEvent('No enemies in spell range (30ft)');
      return;
    }
    
    if (enemies.length === 1) {
      this.executeCast(enemies[0], spell);
    } else {
      this.targetDialog = { targets: enemies, actionType: 'cast', spell };
      this.addEvent(`Cast ${spell} - Choose target (1-${enemies.length}):`, true);
      enemies.forEach((t, i) => {
        this.addEvent(`${i + 1}) ${t.c.n} Cat`, true);
      });
    }
  },
  
  // Execute spell cast
  executeCast(target, spell) {
    const result = P.spell(this.p, target, spell);
    
    this.currentActions--;
    
    if (result.h) {
      const rollText = `1d20+${result.atkBonus} [${result.total}] vs AC ${result.targetAC}`;
      this.addEvent(`${spell}: ${rollText} HIT for ${result.d} damage (${result.die})`);
      if (!target.v) this.addEvent(`${target.c.n} is defeated!`);
    } else if (result.msg) {
      this.addEvent(`${spell}: ${result.msg}`);
    } else {
      const rollText = `1d20+${result.atkBonus} [${result.total}] vs AC ${result.targetAC}`;
      this.addEvent(`${spell}: ${rollText} MISS`);
    }
    
    const alive = this.turnOrder.filter(cat => cat.v);
    if (alive.length <= 1) {
      this.endCombat();
      return;
    }
    
    if (this.currentActions <= 0) this.actionType = null;
  },
  
  // Attempt heal
  attemptHeal() {
    const spells = this.p.c.s || [];
    const healSpells = spells.filter(s => s.startsWith('heal'));
    
    if (healSpells.length === 0) {
      this.addEvent('No healing spells available');
      return;
    }
    
    // Show heal options
    this.addEvent('Choose healing spell:', true);
    this.addEvent('1) Heal (1 action) - 1d8+Wis', true);
    this.addEvent('2) Greater Heal (2 actions) - 2d8+Wis', true);  
    this.addEvent('3) Mass Heal (3 actions) - 3d8+Wis', true);
    
    this.healDialog = true;
  },
  
  // Execute heal
  executeHeal(level) {
    const actionCost = level;
    if (this.currentActions < actionCost) {
      this.addEvent(`Not enough actions (need ${actionCost}, have ${this.currentActions})`);
      return;
    }
    
    const spellName = `heal${level}`;
    const result = P.spell(this.p, null, spellName);
    
    this.currentActions -= actionCost;
    this.addEvent(`${spellName}: Healed ${result.heal} HP (${result.msg})`);
    
    if (this.currentActions <= 0) this.actionType = null;
    this.healDialog = false;
  },
  
  // Attempt stealth
  attemptStealth() {
    const spells = this.p.c.s || [];
    
    if (!spells.includes('hide')) {
      this.addEvent('Stealth not available for this class');
      return;
    }
    
    const result = P.spell(this.p, null, 'hide');
    this.currentActions--;
    this.addEvent(`Hide: ${result.msg}`);
    
    if (this.currentActions <= 0) this.actionType = null;
  },
  
  // Next combat turn
  nextTurn() {
    // Only host can advance turns
    if (this.gameMode !== 'host') return;
    
    // Skip dead cats
    do {
      this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
    } while (!this.turnOrder[this.currentTurn].v);
    
    this.currentActions = 3; // Reset actions for new turn
    this.actionType = null;
    this.attackCount = 0;
    this.moveDistance = 0; // Reset movement
    
    if (this.currentTurn === 0) {
      this.combat.round++;
    }
    
    const currentCat = this.turnOrder[this.currentTurn];
    this.addEvent(`${currentCat.c.n}'s turn begins`);
    
    // Sync turn state to all players
    this.syncTurnState();
    
    // AI behavior for NPCs
    if (currentCat !== this.p && currentCat.v) {
      setTimeout(() => this.runAITurn(currentCat), 1500);
    }
  },
  
  // Run AI turn for a cat
  runAITurn(currentCat) {
    let actions = 3;
    let attacks = 0;
    
    // Find alive targets (exclude self)
    const targets = this.turnOrder.filter(cat => cat.v && cat.id !== currentCat.id);
    if (targets.length === 0) {
      this.endCombat();
      return;
    }
    
    console.log(`${currentCat.c.n} (${currentCat.id}) has ${targets.length} targets: ${targets.map(t => t.c.n + '(' + t.id + ')').join(', ')}`);
    
    // Pick closest target (simple AI - they may attack each other or boss)
    let target = targets[0];
    let minDist = Infinity;
    targets.forEach(cat => {
      if (cat.id === currentCat.id) return; // Double-check to avoid self-targeting
      const dx = cat.pos.x - currentCat.pos.x;
      const dz = cat.pos.z - currentCat.pos.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < minDist) {
        minDist = dist;
        target = cat;
      }
    });
    
    // Safety check - if somehow still targeting self, end turn
    if (target.id === currentCat.id) {
      console.error(`ERROR: ${currentCat.c.n} is targeting itself!`);
      this.nextTurn();
      return;
    }
    
    while (actions > 0 && currentCat.v) {
      // Re-check if target is still alive each action
      if (!target.v) {
        // Target died, find new target
        const newTargets = this.turnOrder.filter(cat => cat.v && cat.id !== currentCat.id);
        if (newTargets.length === 0) {
          this.endCombat();
          return;
        }
        target = newTargets[0]; // Just pick the first available
      }
      
      const dx = target.pos.x - currentCat.pos.x;
      const dz = target.pos.z - currentCat.pos.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      
      console.log(`${currentCat.c.n}(${currentCat.id}) targeting ${target.c.n}(${target.id}): distance=${dist.toFixed(1)}, dx=${dx}, dz=${dz}`);
      
      if (dist <= 5 && target.v) {
        // In range - attack
        const map = attacks * -5;
        const result = P.k(currentCat, target, map);
        
        const mapText = map < 0 ? ` (MAP ${map})` : '';
        const bonusText = result.atkBonus >= 0 ? `+${result.atkBonus}` : `${result.atkBonus}`;
      const rollText = `1d20${bonusText} [${result.total}] vs AC ${result.targetAC}`;
        
        if (result.h) {
          const strText = result.strMod >= 0 ? `+${result.strMod}` : `${result.strMod}`;
        const dmgText = `1d6${strText} [${result.d}]`;
          this.addEvent(`${currentCat.c.n} claw attack${mapText}: ${rollText} HIT for ${dmgText} damage`);
          if (!target.v) this.addEvent(`${target.c.n} is defeated!`);
        } else {
          this.addEvent(`${currentCat.c.n} claw attack${mapText}: ${rollText} MISS`);
        }
        attacks++;
        actions--;
        
        // Sync game state after AI attack
        this.syncGameState();
      } else if (dist > 5) {
        // Move closer - try multiple movement options
        let moved = false;
        let moveDistance = 0;
        
        // Try different movement directions in order of preference
        const directions = [];
        
        if (Math.abs(dx) > Math.abs(dz)) {
          // Prefer X movement, fallback to Z (in grid squares)
          directions.push(
            { x: dx > 0 ? 5 : -5, z: 0 }, // 25ft = 5 grid squares
            { x: dx > 0 ? 4 : -4, z: 0 }, // 20ft = 4 grid squares
            { x: dx > 0 ? 3 : -3, z: 0 }, // 15ft = 3 grid squares  
            { x: dx > 0 ? 2 : -2, z: 0 }, // 10ft = 2 grid squares
            { x: dx > 0 ? 1 : -1, z: 0 }, // 5ft = 1 grid square
            { x: 0, z: dz > 0 ? 5 : -5 },
            { x: 0, z: dz > 0 ? 4 : -4 },
            { x: 0, z: dz > 0 ? 3 : -3 },
            { x: 0, z: dz > 0 ? 2 : -2 },
            { x: 0, z: dz > 0 ? 1 : -1 }
          );
        } else {
          // Prefer Z movement, fallback to X (in grid squares)
          directions.push(
            { x: 0, z: dz > 0 ? 5 : -5 }, // 25ft = 5 grid squares
            { x: 0, z: dz > 0 ? 4 : -4 }, // 20ft = 4 grid squares
            { x: 0, z: dz > 0 ? 3 : -3 }, // 15ft = 3 grid squares
            { x: 0, z: dz > 0 ? 2 : -2 }, // 10ft = 2 grid squares
            { x: 0, z: dz > 0 ? 1 : -1 }, // 5ft = 1 grid square
            { x: dx > 0 ? 5 : -5, z: 0 },
            { x: dx > 0 ? 4 : -4, z: 0 },
            { x: dx > 0 ? 3 : -3, z: 0 },
            { x: dx > 0 ? 2 : -2, z: 0 },
            { x: dx > 0 ? 1 : -1, z: 0 }
          );
        }
        
        // Try each direction until one works
        for (const dir of directions) {
          const newX = currentCat.pos.x + dir.x;
          const newZ = currentCat.pos.z + dir.z;
          
          if (!this.occupied(newX, newZ, currentCat)) {
            currentCat.pos.x = newX;
            currentCat.pos.z = newZ;
            moveDistance = (Math.abs(dir.x) + Math.abs(dir.z)) * 5; // Convert to feet
            moved = true;
            break;
          }
        }
        
        if (moved) {
          // Update cat in scene
          const catIndex = E.objects.findIndex(obj => (obj.type === 'cat' || obj.type === 'boss') && obj.catId === currentCat.id);
          if (catIndex >= 0) {
            E.objects[catIndex].x = currentCat.pos.x;
            E.objects[catIndex].z = currentCat.pos.z;
          }
          actions--;
          this.addEvent(`${currentCat.c.n} moves ${moveDistance}ft closer. ${actions} actions remaining.`);
          
          // Sync game state after AI movement
          this.syncGameState();
        } else {
          // Can't move at all, skip action
          actions--;
          this.addEvent(`${currentCat.c.n} is blocked.`);
        }
      } else {
        break; // No valid actions
      }
    }
    
    // Check if combat should end
    const remaining = this.turnOrder.filter(cat => cat.v);
    if (remaining.length <= 1) {
      this.endCombat();
      return;
    }
    
    this.nextTurn();
  },
  
  // End combat
  endCombat() {
    const aliveCats = this.turnOrder.filter(cat => cat.v);
    const boss = this.turnOrder.find(cat => cat.isBoss);
    
    // Check victory conditions
    if (boss && !boss.v) {
      // Boss defeated - major victory!
      this.addEvent(`üèÜüèÜüèÜ ?????? DEFEATED! The alley is saved!`);
      if (this.p && this.p.v) {
        this.addEvent(`You are victorious!`);
      } else {
        this.addEvent(`You are defeated but witnessed the victory!`);
      }
    } else if (aliveCats.length === 1) {
      if (aliveCats[0].isBoss) {
        this.addEvent(`üíÄ ?????? reigns supreme! All hope is lost...`);
      } else {
        this.addEvent(`üèÜ ${aliveCats[0].c.n} wins the battle!`);
      }
      if (this.p && !this.p.v) {
        this.addEvent(`You are defeated!`);
      }
    } else if (aliveCats.length === 0) {
      this.addEvent(`üíÄ All cats have fallen...`);
    }
    
    this.combat = null;
    this.currentTurn = 0;
    this.currentActions = 3;
    this.actionType = null;
  },
  
  // Render
  render() {
    // Always render the 3D scene for consistent grid background
    E.render();
    
    if (this.s === 'splash' || this.s === 'menu' || this.s === 'lobby') {
      this.renderMenuOverlay();
    } else {
      this.renderUI();
    }
  },
  
  // Render menu overlay on top of 3D scene
  renderMenuOverlay() {
    const ctx = E.ctx;
    
    if (this.s === 'splash') {
      this.renderSplash(ctx);
    } else if (this.s === 'menu') {
      this.renderGameMenu(ctx);
    } else if (this.s === 'lobby') {
      this.renderLobby();
    }
  },
  
  renderSplash(ctx) {
    ctx.textAlign = 'center';
    
    const centerX = E.w / 2;
    const centerY = E.h / 2;
    
    ctx.font = '36px monospace';
    ctx.fillStyle = '#00ffff'; // Cyan
    ctx.fillText('polyhedron games', centerX, centerY - 100);
    
    ctx.font = '24px monospace';
    ctx.fillStyle = '#ffffff';
    ctx.fillText('presents', centerX, centerY - 50);
    
    ctx.font = '48px monospace';
    ctx.fillStyle = '#ffaa00';
    ctx.fillText('Roll for Mischief', centerX, centerY + 20);
    
    ctx.font = '24px monospace';
    ctx.fillStyle = '#888888';
    ctx.fillText('https://polyhedron.games', centerX, centerY + 80);
    
    ctx.font = '18px monospace';
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Press SPACE to continue', centerX, centerY + 140);
    
    ctx.textAlign = 'left';
  },
  
  renderGameMenu(ctx) {
    const centerX = E.w / 2;
    const centerY = E.h / 2;
    
    // Normal cat cursor position
    const cursorX = centerX - 60;
    const cursorY = centerY + (this.menuSelection * 60) - 52;
    
    // Align title with cursor - get cursor left edge
    ctx.font = '48px monospace';
    ctx.textAlign = 'left'; // Change to left align
    ctx.fillStyle = '#ffaa00';
    ctx.fillText('Roll for Mischief', cursorX, centerY - 100);
    
    // Big boss cat on the left side - render actual sprite
    const bossX = centerX - 350;
    const bossY = centerY - 120;
    this.renderCatSprite(ctx, bossX, bossY, 200, '#000000', true); // Boss sprite
    
    // Menu options
    ctx.font = '32px monospace';
    const options = ['Start Game', 'Join Game'];
    
    options.forEach((option, i) => {
      const y = centerY + (i * 60) - 20;
      ctx.fillStyle = this.menuSelection === i ? '#ffffff' : '#888888';
      ctx.fillText(option, centerX + 60, y);
    });
    
    // Normal cat cursor - render actual sprite
    this.renderCatSprite(ctx, cursorX, cursorY, 48, '#ffaa00', false);
    
    ctx.textAlign = 'left';
    
    // Instructions
    ctx.font = '16px monospace';
    ctx.fillStyle = '#cccccc';
    ctx.fillText('Use W/S or Arrow Keys to navigate', 20, E.h - 60);
    ctx.fillText('Press ENTER to select', 20, E.h - 40);
  },
  
  renderCatSprite(ctx, x, y, size, baseColor, isBoss) {
    // Use the actual sprite data from SPRITES.cat
    if (!SPRITES || !SPRITES.cat) return;
    
    const spriteData = SPRITES.cat.data;
    const colors = SPRITES.cat.colors;
    const spriteSize = SPRITES.cat.size; // 32x32
    const pixelSize = size / spriteSize;
    
    // Each character in spriteData represents one pixel
    // '0' = transparent, other characters = color keys
    let pixelIndex = 0;
    
    for (let i = 0; i < spriteData.length; i++) {
      const colorKey = spriteData[i];
      
      if (colorKey !== '0') { // Skip transparent pixels
        const color = isBoss && colorKey !== '0' ? '#000000' : (colors[colorKey] || baseColor);
        if (color) {
          const px = pixelIndex % spriteSize;
          const py = Math.floor(pixelIndex / spriteSize);
          
          ctx.fillStyle = color;
          ctx.fillRect(
            x + px * pixelSize,
            y + py * pixelSize,
            pixelSize,
            pixelSize
          );
        }
      }
      
      pixelIndex++;
    }
    
    // Add boss cat yellow eyes if needed
    if (isBoss) {
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(x + 14 * pixelSize, y + 10 * pixelSize, 4 * pixelSize, 3 * pixelSize);
      ctx.fillRect(x + 22 * pixelSize, y + 10 * pixelSize, 4 * pixelSize, 3 * pixelSize);
    }
  },
  
  // Update UI elements
  updateUI() {
    // Hide UI elements in lobby/menu states
    const hideUI = this.s === 'splash' || this.s === 'menu' || this.s === 'lobby';
    
    const stats = document.querySelector('.stats-panel');
    if (stats) stats.style.display = hideUI ? 'none' : 'block';
    
    const eventLog = document.querySelector('.event-log');
    if (eventLog) eventLog.style.display = hideUI ? 'none' : 'block';
    
    const leaderboard = document.querySelector('.leaderboard');
    if (leaderboard) leaderboard.style.display = hideUI ? 'none' : 'block';
    
    if (!hideUI) {
      const statsDiv = document.querySelector('#player-stats div');
      if (statsDiv && this.p) {
        statsDiv.innerHTML = `<strong>${this.p.c.n} Cat</strong><br>HP: ${this.p.h}/${this.p.m}<br>AC: ${this.p.a}<br>Pos: (${this.p.pos.x}, ${this.p.pos.z})`;
      }
      
      const lb = document.querySelector('#leaderboard-list');
      if (lb) {
        const connected = (this.ws && this.ws.readyState === 1) || (this.w && this.w.readyState === 1);
        const count = this.cs.filter(c => c.v).length + (this.p && this.p.v ? 1 : 0);
        lb.innerHTML = connected ? `Connected: ${count} cats` : 'Connecting...';
      }
    }
  },
  
  // Render UI
  renderUI() {
    this.updateUI();
    
    const ctx = E.ctx;
    
    // Combat UI - horizontal initiative bar like screenshot
    if (this.combat) {
      // Initiative tracker - horizontal bar in top center
      const boxWidth = 120;
      const boxHeight = 60; // Increased height for bigger cats
      const startX = (E.w - (this.turnOrder.length * boxWidth)) / 2;
      const startY = 10;
      
      this.turnOrder.forEach((cat, i) => {
        const x = startX + i * boxWidth;
        const active = i === this.currentTurn;
        
        // Box background
        ctx.fillStyle = active ? 'rgba(255,255,0,0.8)' : 'rgba(0,0,0,0.7)';
        ctx.fillRect(x, startY, boxWidth - 2, boxHeight);
        
        // Border
        ctx.strokeStyle = active ? '#ffff00' : '#666666';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, startY, boxWidth - 2, boxHeight);
        
        // Cat head sprite (using same clip as skull effect) - bigger now
        if (SPRITES && SPRITES.cat) {
          const headSize = 30; // Bigger size for initiative tracker
          const headX = x + 5;
          const headY = startY + 5;
          
          // Calculate 75% height clip (same as skull effect)
          const spriteSize = SPRITES.cat.size;
          const clipHeight = Math.floor(spriteSize * 0.75);
          
          // Render clipped sprite
          for (let sy = 0; sy < clipHeight; sy++) {
            for (let sx = 0; sx < spriteSize; sx++) {
              const index = sy * spriteSize + sx;
              const char = SPRITES.cat.data[index];
              
              if (char && char !== '0' && SPRITES.cat.colors[char]) {
                let color = SPRITES.cat.colors[char];
                
                // Apply cat's color tinting
                if (cat.color !== '#f07010') {
                  const catR = parseInt(cat.color.slice(1, 3), 16);
                  const catG = parseInt(cat.color.slice(3, 5), 16);
                  const catB = parseInt(cat.color.slice(5, 7), 16);
                  const origR = parseInt(color.slice(1, 3), 16);
                  const origG = parseInt(color.slice(3, 5), 16);
                  const origB = parseInt(color.slice(5, 7), 16);
                  
                  const tintedR = Math.min(255, Math.floor((origR * catR) / 255));
                  const tintedG = Math.min(255, Math.floor((origG * catG) / 255));
                  const tintedB = Math.min(255, Math.floor((origB * catB) / 255));
                  
                  color = `#${tintedR.toString(16).padStart(2,'0')}${tintedG.toString(16).padStart(2,'0')}${tintedB.toString(16).padStart(2,'0')}`;
                }
                
                ctx.fillStyle = color;
                const pixelX = headX + Math.floor(sx * headSize / spriteSize);
                const pixelY = headY + Math.floor(sy * headSize / spriteSize);
                const pixelSize = Math.max(1, Math.floor(headSize / spriteSize));
                ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
              }
            }
          }
        }
        
        // Text - use black text for readability on yellow highlight
        ctx.font = '10px monospace';
        ctx.fillStyle = active ? '#000000' : (cat.color === '#000000' ? '#ffffff' : cat.color); // Black for active, cat color otherwise
        ctx.fillText(cat.c.n, x + 40, startY + 15); // Moved further right for bigger sprite
        
        // Regular text color
        ctx.fillStyle = active ? '#000000' : '#ffffff'; // Black for active cat, white otherwise
        
        // Show HP for player's cat, health status for others
        if (cat === this.p) {
          ctx.fillText(`HP: ${cat.h}/${cat.m}`, x + 40, startY + 28); // Second line
          ctx.fillText(`Init: ${cat.i}`, x + 40, startY + 45); // Third line
        } else {
          // Show health status for other cats
          const hpPercent = cat.h / cat.m;
          let healthStatus = 'Healthy';
          if (hpPercent <= 0) healthStatus = 'Defeated';
          else if (hpPercent <= 0.25) healthStatus = 'Critical';
          else if (hpPercent <= 0.5) healthStatus = 'Bloodied';
          else if (hpPercent <= 0.75) healthStatus = 'Injured';
          
          ctx.fillText(healthStatus, x + 40, startY + 28); // Second line  
          ctx.fillText(`Init: ${cat.i}`, x + 40, startY + 45); // Third line
        }
      });
      
    }
    
    // Bottom left panel
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(10, E.h - 100, 300, 90);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    
    if (this.combat) {
      // Stat block display (T key toggle)
      if (this.showStatBlock && this.p.v) {
        const statY = E.h - 250; // Higher above the combat controls
        ctx.fillStyle = '#00ffff';
        ctx.fillText(`${this.p.c.n} Stats:`, 20, statY);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`HP: ${this.p.h}/${this.p.m}`, 20, statY + 15);
        ctx.fillText(`AC: ${this.p.a}`, 20, statY + 30);
        
        // Left column - ability scores
        const strMod = Math.floor((this.p.s.S - 10) / 2);
        const dexMod = Math.floor((this.p.s.D - 10) / 2);
        const conMod = Math.floor((this.p.s.C - 10) / 2);
        const intMod = Math.floor((this.p.s.I - 10) / 2);
        const wisMod = Math.floor((this.p.s.W - 10) / 2);
        const chaMod = Math.floor((this.p.s.H - 10) / 2);
        
        ctx.fillText(`STR: ${this.p.s.S} (${strMod >= 0 ? '+' : ''}${strMod})`, 20, statY + 45);
        ctx.fillText(`DEX: ${this.p.s.D} (${dexMod >= 0 ? '+' : ''}${dexMod})`, 20, statY + 60);
        ctx.fillText(`CON: ${this.p.s.C} (${conMod >= 0 ? '+' : ''}${conMod})`, 20, statY + 75);
        ctx.fillText(`INT: ${this.p.s.I} (${intMod >= 0 ? '+' : ''}${intMod})`, 20, statY + 90);
        ctx.fillText(`WIS: ${this.p.s.W} (${wisMod >= 0 ? '+' : ''}${wisMod})`, 20, statY + 105);
        ctx.fillText(`CHA: ${this.p.s.H} (${chaMod >= 0 ? '+' : ''}${chaMod})`, 20, statY + 120);
        
        // Right column - combat stats with damage
        const meleeBonus = this.p.c.a + strMod;
        const meleeDmg = `1d6+${strMod}`;
        ctx.fillText(`Melee: +${meleeBonus} (${meleeDmg})`, 180, statY + 45);
        
        // Show spell attack bonus if has spells
        const classSpells = this.p.c.s || [];
        if (classSpells.includes('firebolt')) {
          const spellBonus = this.p.c.a + intMod;
          ctx.fillText(`Spell: +${spellBonus} (1d10)`, 180, statY + 60);
        }
        if (classSpells.includes('harm')) {
          const spellBonus = this.p.c.a + wisMod;
          const spellDmg = `1d8+${wisMod}`;
          ctx.fillText(`Spell: +${spellBonus} (${spellDmg})`, 180, statY + 60);
        }
        if (classSpells.includes('hide')) {
          ctx.fillText(`Stealth: +${dexMod}`, 180, statY + 75);
        }
      }
      
      // Combat controls in green in bottom left
      const currentCat = this.turnOrder[this.currentTurn];
      if (currentCat === this.p && this.p.v) {
        ctx.fillStyle = '#00ff00';
        const actionsText = `Actions: ${this.currentActions}/3`;
        ctx.fillText(actionsText, 20, E.h - 80);
        
        // Action dots with space after Actions text
        const textWidth = ctx.measureText(actionsText).width;
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = i < this.currentActions ? '#00ff00' : '#666666';
          ctx.beginPath();
          ctx.arc(30 + textWidth + i * 15, E.h - 85, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.fillStyle = '#00ff00';
        const modeText = this.actionType === 'move' 
          ? `Mode: ${this.actionType} (${this.moveDistance}/25ft)`
          : `Mode: ${this.actionType || 'None'}`;
        ctx.fillText(modeText, 20, E.h - 65);
        const classSpells = this.p.c.s || [];
        let helpText = 'M=Move, X=Attack';
        if (classSpells.includes('firebolt') || classSpells.includes('harm')) helpText += ', C=Cast';
        if (classSpells.some(s => s.startsWith('heal'))) helpText += ', H=Heal';
        if (classSpells.includes('hide')) helpText += ', Z=Stealth';
        
        // Always show basic controls on first line
        const basicText = 'M=Move, X=Attack, T=Stats';
        ctx.fillText(basicText, 20, E.h - 50);
        
        // Show specials on second line if any
        const specialsText = helpText.replace('M=Move, X=Attack', '').trim();
        if (specialsText) {
          ctx.fillText(specialsText.substring(2), 20, E.h - 35); // Remove leading ', '
        }
        
        // Show end turn on third line
        ctx.fillText('Space=End Turn', 20, E.h - 20);
      } else {
        ctx.fillStyle = '#ffff00';
        ctx.fillText(`${currentCat.c.n}'s Turn`, 20, E.h - 80);
        ctx.fillStyle = '#fff';
        if (!this.p.v) {
          ctx.fillStyle = '#ff0000';
          ctx.fillText('You are defeated!', 20, E.h - 65);
          ctx.fillText('Watching remaining combat...', 20, E.h - 50);
        } else {
          ctx.fillText('Waiting for enemy...', 20, E.h - 65);
        }
      }
    } else {
      // Regular help text
      ctx.fillText('WASD: Move camera', 20, E.h - 80);
      ctx.fillText('Mouse: Look around', 20, E.h - 65);
      ctx.fillText('Scroll: Zoom', 20, E.h - 50);
      ctx.fillText('Arrows: Move cat', 20, E.h - 35);
      ctx.fillText('I: Isometric view', 20, E.h - 20);
    }
    
    // Event log is now handled via HTML element
  }
};

// Start
document.addEventListener('DOMContentLoaded', () => {
  window.G = G; // Make globally accessible for 3D engine
  G.init();
});
    </script>
</body>
</html>